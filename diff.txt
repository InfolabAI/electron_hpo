diff --git a/.gitignore b/.gitignore
deleted file mode 100644
index e517da9..0000000
--- a/.gitignore
+++ /dev/null
@@ -1,28 +0,0 @@
-# 빌드 결과물
-project/dist/
-
-# 의존성
-project/node_modules/
-project/env/
-
-# 스크립트 파일
-project/build_transfer.sh
-
-# 압축 파일
-*.zip
-
-# 데이터베이스 파일
-*.sqlite3
-
-# 시스템 파일
-.DS_Store
-Thumbs.db
-
-# 로그 파일
-*.log
-
-.vscode/
-cpp_codes/
-python_scripts_backup/
-HPOptimizer 메뉴얼.pdf
-wandb_min_max_test.py
diff --git a/project/dashboardPreload.js b/project/dashboardPreload.js
index 3eb1009..f6b759f 100644
--- a/project/dashboardPreload.js
+++ b/project/dashboardPreload.js
@@ -4,20 +4,22 @@ window.addEventListener('DOMContentLoaded', () => {
     console.log('dashboardPreload.js done.');
     try {
         // 1) Dark Mode 스위치가 체크되어 있다면 클릭해서 라이트 모드로 전환
-        // 문제: 시점 문제. 즉, Material-UI(React) 앱이 로드되는 과정에서, DOMContentLoaded가 이미 뜬 뒤에야 해당 스위치가 “마운트”되거나, 체크 상태가 바뀔 수 있음.
-        // 해결: 그래서, MutationObserver 로 “body 내부에 자식이 추가/변경”되는 순간을 계속 감시하다가 darkSwitch가 나타나고 checked=true인 상태가 되면 클릭해서 라이트 모드로 전환합니다.
+        // 문제: 시점 문제. 즉, Material-UI(React) 앱이 로드되는 과정에서, DOMContentLoaded가 이미 뜬 뒤에야 해당 스위치가 "마운트"되거나, 체크 상태가 바뀔 수 있음.
+        // 해결: 그래서, MutationObserver 로 "body 내부에 자식이 추가/변경"되는 순간을 계속 감시하다가 darkSwitch가 나타나고 checked=true인 상태가 되면 클릭해서 라이트 모드로 전환합니다.
         const observer = new MutationObserver((mutations, obs) => {
             let doneDarkMode = false;
             let doneStackText = false;
             let doneToolbarText = false;
 
-            // (1) 다크 모드 스위치 끄기
+            // (1) 다크 모드 스위치 끄기 - 주석 처리하여 다크 모드 유지
+            /*
             const darkSwitch = document.querySelector('input[aria-labelledby="switch-list-label-dark-mode"]');
             if (darkSwitch && darkSwitch.checked) {
                 darkSwitch.click();
                 console.log('Switched to Light Mode');
             }
-            // 스위치가 없거나 이미 꺼져 있어도, 일단 “처리 끝”으로 설정 (무한 반복 방지)
+            */
+            // 스위치가 없거나 이미 꺼져 있어도, 일단 "처리 끝"으로 설정 (무한 반복 방지)
             doneDarkMode = true;
 
             // (2) h5Element "Heechul Lim"으로 변경
diff --git a/project/index copy.html b/project/index copy.html
deleted file mode 100644
index caf0cdb..0000000
--- a/project/index copy.html	
+++ /dev/null
@@ -1,794 +0,0 @@
-<!DOCTYPE html>
-<html lang="ko">
-
-<head>
-    <meta charset="UTF-8" />
-    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
-    <title>Hyperparameter Optimizer</title>
-
-    <!-- head 내부 -->
-    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
-
-    <style>
-        body {
-            margin: 0;
-            font-family: sans-serif;
-        }
-
-        .tab-content {
-            display: none;
-            /* 기본적으로 감춰놓고, 선택된 탭만 표시 */
-        }
-
-        .tab-content.active {
-            display: block;
-            /* 선택된 탭은 보이게 */
-        }
-    </style>
-</head>
-
-<body>
-    <!-- 
-    1) "container-fluid": 
-    - Bootstrap에서 지원하는 레이아웃 컨테이너 중 하나로, 
-        가로 폭을 브라우저(또는 부모 요소) 전체 폭에 맞게 100%로 사용함.
-    - "container"와 달리 반응형 최대 폭 제한이 없고, 
-        항상 수평으로 화면 전체를 차지할 수 있음.
-    
-    2) "h-100":
-    - Bootstrap 유틸리티 클래스 중 하나로, 
-        height: 100% (세로 높이 100%)를 의미.
-    - 부모 요소(여기서는 <body> 또는 <html> 등) 높이가 정해져 있어야 
-        100%가 유효하게 동작함.
-    - 제거하면 해당 컨테이너는 자동으로 내용물에 따라 높이가 달라짐.
-    -->
-
-    <div class="container-fluid h-100">
-        <!-- Bootstrap의 row로 수평 배치, 높이 100% -->
-        <!-- 
-        1) "row": 
-        - Bootstrap의 grid system에서, 
-            "열(col)"들을 수평 방향으로 배치하는 '행' 컨테이너.
-        - 내부에 "col", "col-auto" 등의 컬럼들이 들어갈 때 사용할 수 있음.
-
-        2) "h-100":
-        - 이 row도 높이를 100%로 맞춤.
-        - 상위 요소가 이미 h-100이므로, 
-            row도 같이 세로 100%가 유지되어 
-            양쪽(col-auto, col)도 세로로 가득 차게 배치 가능.
-
-        3) "g-0":
-        - "g-0"은 "gutter: 0"을 뜻함.
-        - 기본적으로 col 사이에는 일정 간격(gutter)이 생기는데, 
-            이 클래스를 주면 그 간격을 0으로 만들어 
-            컬럼 사이 공백이 없게 함.
-        - 만약 g-0을 제거하면, col 사이에 기본적인 
-            수평 공간(보통 1.5rem) 정도가 생김.
-        -->
-
-        <div class="row h-100 g-0">
-
-
-            <!-- 왼쪽 사이드바: 고정 폭(col-auto) + 배경색 -->
-            <!-- 
-            1) col-auto: 내용물 크기에 맞춰 자동으로 폭이 결정된다.
-                => 이 내부의 버튼이 작아지면(텍스트에 맞는 너비),
-                    col-auto 자체도 그만큼 폭이 작아진다.
-
-            2) d-block: 버튼을 display: block 으로 처리.
-                => 기본적으로 inline-block 성격이 사라져, 
-                    width, margin 등의 적용 방식이 달라짐.
-
-            3) mx-auto: 좌우 마진을 auto로 설정.
-                => display: block인 요소가 부모 안에서 
-                    수평 가운데 정렬된다.
-                => 단, 별도로 width(예: w-50 등)를 지정하지 않으면, 
-                    내용(텍스트) 길이에 따라 최소 폭이 결정됨 
-                    (결과적으로 버튼 폭이 텍스트 크기에 맞춰짐).
-
-            즉, "d-block mx-auto"만 쓰면 
-            -> 버튼 폭이 내부 텍스트에 맞춰 작아지고, 
-            -> 사이드바(col-auto)도 그 폭에 맞게 줄어든다.
-
-            만약 버튼을 고정 폭이나 비율로 유지하고 싶다면
-            "w-50 d-block mx-auto" 같은 식으로 함께 써서
-            너비 50% + 중앙 정렬을 적용할 수 있다.
-            -->
-
-            <div class="col-auto bg-secondary text-white p-3">
-                <!--
-                Bootstrap button:
-                    - btn          : 기본 버튼 스타일
-                    - btn-primary  : 파란색 계열 (Primary) 버튼
-                    - w-100        : 버튼 너비를 100%로 지정 (부모의 100%)
-                    - mb-2         : 아래쪽 여백(margin-bottom) 0.5rem
-                id="btnMain": 자바스크립트에서 document.getElementById('btnMain') 등을 통해
-                                클릭 이벤트 등을 연결하기 위해 쓰임
-                -->
-                <button class="btn btn-primary w-100 d-block mx-auto mb-2" id="btnMain">Main</button>
-                <button class="btn btn-warning w-100 d-block mx-auto mb-2" id="btnSettings">Settings</button>
-                <!--<button class="btn btn-success w-100 d-block mx-auto mb-2" id="btnResults">Results</button>-->
-                <!-- 기존 버튼들 아래에 Dashboard 버튼 하나 추가 -->
-                <button class="btn btn-success w-100 d-block mx-auto mt-2" id="btnDashboard">Dashboard</button>
-
-            </div>
-
-            <!-- 오른쪽 컨텐츠: 남은 공간(col) -->
-            <!-- 
-            1) "col":
-            - Bootstrap Grid System에서
-                '남은 공간을 유연하게 차지하는 컬럼' 역할.
-            - "col-auto"나 숫자 지정(col-4, col-6 등)과 달리, 
-                row 내에서 자동으로 남아있는 부분을 고루 분할해 가짐.
-
-            2) "p-4":
-            - padding: (약) 1.5rem 정도로 설정.
-            - 내부 컨텐츠에 넉넉한 여백을 주어, 
-                요소들이 가장자리와 떨어져 보이게 됨.
-            -->
-
-            <div class="col p-4">
-
-
-                <!-- 메인 탭 -->
-                <!-- 
-                id="mainTab": 
-                    - JavaScript에서 document.getElementById('mainTab')로 
-                    접근하기 위한 식별자.
-                    - 탭 전환 로직에서 '메인 탭'을 가리킬 때 사용.
-
-                class="tab-content active":
-                    - "tab-content": 탭 전환에 사용되는 공통 클래스. 
-                    보통 CSS에서 display: none 처리해둔 상태.
-                    - "active": 이 탭이 현재 화면에 표시되는 상태를 의미. 
-                    (CSS에서 .tab-content.active { display: block; } 등으로 제어)
-                -->
-                <div id="mainTab" class="tab-content active">
-
-                    <!-- <h1>Locate optimizer path</h1> -->
-
-                    <!--
-                    <div class="input-group mb-3">
-                    - Bootstrap의 input-group: 
-                        텍스트 입력과 버튼 등 여러 요소를 
-                        하나의 그룹으로 보기 좋게 묶어주는 구성.
-                    - mb-3: "margin-bottom: 1rem" 정도로, 
-                        아래쪽에 간격을 줌.
-                    -->
-                    <div class="input-group mb-3">
-                        <!-- 
-                        <input type="text" class="form-control" id="command" placeholder="Python path..." />
-                            - 입력 필드:
-                            - class="form-control": 부트스트랩 양식(입력창) 스타일 적용.
-                            - id="command": JS에서 값을 읽거나 변경할 때 사용.
-                            - placeholder="Python path...": 
-                                사용자가 입력하기 전에 표시할 안내 텍스트.
-                        <input type="text" class="form-control" id="command" placeholder="Python path..." />
-                        -->
-
-                        <!--
-                        <button class="btn btn-outline-secondary" onclick="selectFile('command')">Browse</button>
-                            - class="btn btn-outline-secondary": 
-                            부트스트랩 버튼 스타일(회색 테두리, 흰 배경).
-                            - onclick="selectFile('command')": 
-                            버튼을 클릭하면 JavaScript의 selectFile() 함수를 호출, 
-                            'command'라는 인자를 넘겨 해당 input에 파일 경로를 세팅하도록 구현.
-                        <button class="btn btn-outline-secondary" onclick="selectFile('command')">Browse</button>
-                        -->
-                        <div class="input-group mb-3">
-                            <span class="input-group-text">Number of Trials</span>
-                            <input type="text" class="form-control" id="n_trials" placeholder="The number of trials..."
-                                value="30" />
-                        </div>
-                    </div>
-
-                    <div class="input-group mb-3">
-                        <!--
-                        두 번째 input-group (args 입력)
-                        - 구조와 역할은 위와 동일, id 및 placeholder만 다름.
-                        <input type="text" class="form-control" id="args" placeholder="Optuna path..." />
-                        <button class="btn btn-outline-secondary" onclick="selectFile('args')">Browse</button>
-                        -->
-                    </div>
-
-                    <!--
-                    <button class="btn btn-primary" id="runBtn">Run</button>
-                    - 부트스트랩 파란색(Primary) 버튼.
-                    - id="runBtn": 클릭 이벤트를 JS에서 걸어 
-                        실제 'run' 동작을 수행하게 함.
-                    -->
-                    <button class="btn btn-primary" id="runBtn">Run</button>
-
-                    <!--
-                    <pre id="output" class="mt-3 p-3 bg-light" style="border: 1px solid #ccc;"></pre>
-                    - <pre>: 공백과 줄바꿈을 그대로 보존하는 블록.
-                    - id="output": 실시간 로그나 결과 텍스트를 표시하는 용도.
-                    - class="mt-3": 상단 마진(3단계, 약 1rem).
-                    - class="p-3 bg-light": 안쪽 여백 + 연한 배경색.
-                    - style="border: 1px solid #ccc;": 테두리 지정 (회색 라인).
-                    -->
-                    <pre id="output" class="mt-3 p-3 bg-light" style="border: 1px solid #ccc;"></pre>
-
-                </div>
-
-
-                <!-- 설정 탭 -->
-                <!-- 
-                id="settingsTab":
-                    - JS에서 document.getElementById('settingsTab')로 접근 가능.
-                    - 탭 전환 시, "설정" 탭으로 표시될 영역.
-
-                class="tab-content":
-                    - 탭 공통 클래스. 
-                    - 일반적으로 CSS에서 .tab-content { display: none; } 처리,
-                    active 상태에서만 display: block; 되어 보이도록 제어.
-                    - 이 탭은 현재 "active" 클래스가 없으므로 초기에는 숨겨짐.
-                -->
-                <div id="settingsTab" class="tab-content">
-
-                    <!-- 
-                    <h1>설정</h1>
-                        - 큰 제목: "설정" 섹션이라는 것을 알려줌.
-                    -->
-                    <h1>Settings</h1>
-
-                    <!-- 
-                    <button class="btn btn-info mb-3" id="addRowBtn">+ 행 추가</button>
-                        - btn: 부트스트랩 버튼 기본 스타일
-                        - btn-info: 밝은 하늘색/청록색 계열 버튼
-                        - mb-3: 하단 여백(margin-bottom) 1rem (약 16px) 정도
-                        - id="addRowBtn": JS에서 클릭 이벤트를 연결해 "행 추가" 기능 구현
-                    -->
-                    <button class="btn btn-info mb-3" id="addRowBtn">+ Add Row</button>
-
-                    <!-- 
-                    <table id="settingsTable" class="table table-bordered">
-                        - table: 부트스트랩 표 기본 스타일 (적절한 간격과 텍스트 정렬)
-                        - table-bordered: 각 셀에 테두리가 있는 표
-                        - id="settingsTable": JS에서 이 테이블을 찾아 행 추가/삭제를 동적으로 구현
-                        - text-center: 가운데 정렬
-                    -->
-                    <table id="settingsTable" class="table table-bordered text-center">
-                        <thead class="table-secondary">
-                            <tr>
-                                <!-- 
-                                <th>-</th>: 첫 열은 행 삭제 버튼 표시에 사용
-                                <th>Type</th>, <th>Name</th>, <th colspan="4">Config</th>
-                                    - 이후 "Type" 선택에 따라 int/float/category의 세부 설정을 
-                                    동적으로 보여줄 수 있음.
-                                -->
-                                <th>-</th>
-                                <th>Type</th>
-                                <th>Name</th>
-                                <th colspan="4">Config</th>
-                            </tr>
-                        </thead>
-                        <tbody>
-                            <!-- 동적 행 추가 영역 -->
-                            <!-- 
-                            JS로 행(tr)을 생성해 추가할 때,
-                            <td>에 select, input 등을 넣어서 
-                            사용자 설정 정보를 수집하는 구조.
-                            -->
-                        </tbody>
-                    </table>
-
-                    <!-- 
-                    하단의 저장/초기화 버튼:
-                        - "btn btn-success": 녹색 계열(성공 메세지 느낌)
-                        - "btn btn-warning": 노란 계열(주의 표시 느낌)
-                    id="saveBtn" / id="resetBtn":
-                        - JS 이벤트 바인딩을 위해 사용.
-                        - "저장": 설정 내용 JSON으로 export, 파일 저장 등
-                        - "초기화": 테이블 행 및 값들을 클리어
-                    -->
-                    <button class="btn btn-success" id="saveBtn">Save</button>
-                    <button class="btn btn-warning" id="resetBtn">Reset</button>
-
-                </div>
-
-
-                <!-- 결과 탭 -->
-                <div id="resultsTab" class="tab-content">
-                    <h1>Results</h1>
-                    <pre id="output_ret" class="p-3 bg-light" style="border: 1px solid #ccc;"></pre>
-                </div>
-
-                <!-- Dashboard Tab. preload 할 js 실행 문제로 버튼 클릭시 webview 로드하도록 개발함 -->
-                <div id="dashboardTab" class="tab-content">
-                </div>
-
-            </div> <!-- col 끝 -->
-        </div> <!-- row 끝 -->
-    </div> <!-- container-fluid 끝 -->
-
-    <script>
-        // 탭 전환 로직
-        const btnMain = document.getElementById("btnMain");
-        const btnSettings = document.getElementById("btnSettings");
-        //const btnResults = document.getElementById("btnResults");
-        const btnDashboard = document.getElementById("btnDashboard");
-        const mainTab = document.getElementById("mainTab");
-        const settingsTab = document.getElementById("settingsTab");
-        const resultsTab = document.getElementById("resultsTab");
-        const dashboardTab = document.getElementById("dashboardTab");
-
-
-        btnMain.addEventListener("click", () => {
-            mainTab.classList.add("active");
-            settingsTab.classList.remove("active");
-            resultsTab.classList.remove("active");
-            dashboardTab.classList.remove("active");
-        });
-        btnSettings.addEventListener("click", async () => {
-            mainTab.classList.remove("active");
-            settingsTab.classList.add("active");
-            resultsTab.classList.remove("active");
-            dashboardTab.classList.remove("active");
-            // 설정 탭 들어갈 때마다 config.json 불러오기
-            await loadConfig();
-        });
-        //btnResults.addEventListener("click", async () => {
-        //    mainTab.classList.remove("active");
-        //    settingsTab.classList.remove("active");
-        //    resultsTab.classList.add("active");
-        //    dashboardTab.classList.remove("active");
-        //    // 결과 탭 들어갈 때마다 결과 불러오기
-        //    await loadResults();
-        //});
-        // 버튼 클릭 시 다른 탭들의 active 제거 후 dashboardTab에 active 부여
-        // 버튼을 클릭했을 때, webview 를 동적으로 만들어야 preloadAbsolutePath(즉, dashboardPreload.js)를 webview 가 정상적으로 열 수 있음
-        btnDashboard.addEventListener("click", async () => {
-            mainTab.classList.remove("active");
-            settingsTab.classList.remove("active");
-            resultsTab.classList.remove("active");
-            dashboardTab.classList.add("active");
-            // 1) dashboardTab 내부의 기존 webview가 있으면 제거 (이미 만들어진 적이 있으면)
-            const existingWebview = document.querySelector('#dashboardTab webview');
-            if (existingWebview) {
-                existingWebview.remove();
-            }
-
-            // 2) Webview를 동적으로 생성
-            const webview = document.createElement('webview');
-
-            // 3) 동적 경로(예: preloadAbsolutePath) 가져오기
-            const preloadAbsolutePath = await window.electronAPI.getDashboardPreloadPath();
-            // 반드시 file:// 붙이거나 pathToFileURL(preloadAbsolutePath).href 등으로 처리
-            //const finalPreloadURL = 'file://' + preloadAbsolutePath;
-
-            // 4) Webview 속성 설정
-            webview.setAttribute('preload', preloadAbsolutePath);
-            webview.setAttribute('src', 'http://localhost:8080');
-            webview.style.width = '100%';
-            webview.style.height = '800px';
-            webview.style.border = 'none';
-
-
-            // 5) dashboardTab div에 삽입
-            dashboardTab.appendChild(webview);
-
-            //webview.addEventListener('dom-ready', () => {
-            //    webview.openDevTools(); // webview 는 개발자 도구를 따로 사용하므로, 필요하다면 여기서 열어줘야 함.
-            //});
-
-        });
-
-        // ---------------------
-        // 메인 탭 (기존 기능)
-        // ---------------------
-        const runBtn = document.getElementById('runBtn');
-        // const cmdInput = document.getElementById('command');
-        // const argsInput = document.getElementById('args');
-        const nTrialsInput = document.getElementById('n_trials');
-        const outputArea = document.getElementById('output');
-        const outputRetArea = document.getElementById('output_ret');
-
-        // =============== 실시간 로그를 뿌릴 이벤트 연결 ===============
-        // main -> renderer 통신
-        window.electronAPI.onCommandStdout((data) => {
-            outputArea.textContent += data; // 그냥 이어붙이면 됨
-        });
-
-        window.electronAPI.onCommandStderr((data) => {
-            outputArea.textContent += '[ERR] ' + data; // 현재는 에러는 표시 안함
-        });
-
-        window.electronAPI.onCommandClose((code) => {
-            outputArea.textContent += `\n--- Process exited with code: ${code} ---\n`;
-        });
-
-        window.electronAPI.onCommandError((errMsg) => {
-            outputArea.textContent += `[ERROR] ${errMsg}\n`;
-        });
-        // ============================================================
-
-        runBtn.addEventListener('click', async () => {
-            // 공백으로 구분된 인자를 배열로
-            //const cmd = cmdInput.value.trim();
-            const cmd = '';
-            //const args = argsInput.value.trim().split(' ');
-            const n_trials = nTrialsInput.value.trim();
-            const args = '';
-
-            outputArea.textContent = 'Running command...\n';
-
-            try {
-                // 프로세스 시작
-                const result = await window.electronAPI.runCommand(cmd, args, n_trials);
-                // 여기 도달 시점: 프로세스가 종료된 뒤
-                outputArea.textContent += `\nProcess ended. code=${result.code}\n`;
-            } catch (err) {
-                outputArea.textContent += `\n[ERROR] ${err.message}\n`;
-            }
-        });
-
-
-        function selectFile(inputId) {
-            const inputElement = document.getElementById(inputId);
-            const fileInput = document.createElement("input");
-            fileInput.type = "file";
-            fileInput.style.display = "none";
-
-            fileInput.onchange = function (event) {
-                if (event.target.files.length > 0) {
-                    inputElement.value = event.target.files[0].path;
-                }
-            };
-
-            document.body.appendChild(fileInput);
-            fileInput.click();
-            document.body.removeChild(fileInput);
-        }
-
-        // ---------------------
-        // 설정 탭
-        // ---------------------
-        const addRowBtn = document.getElementById("addRowBtn");
-        const saveBtn = document.getElementById("saveBtn");
-        const resetBtn = document.getElementById("resetBtn");
-        const settingsTableBody = document.querySelector("#settingsTable tbody");
-
-        // 행 추가 버튼 클릭 시
-        addRowBtn.addEventListener("click", () => {
-            addRow();
-        });
-
-        // 초기화 버튼 클릭 시
-        resetBtn.addEventListener("click", () => {
-            settingsTableBody.innerHTML = ""; // 테이블 초기화
-        });
-
-        // 저장 버튼 클릭 시
-        saveBtn.addEventListener("click", async () => {
-            // 테이블 내용을 JSON 형태로 추출
-            const data = tableToJson();
-            // IPC로 main process에 저장 요청
-            await window.electronAPI.saveConfig(data);
-            alert("Saved!");
-        });
-
-        // 설정 탭 들어갈 때 불러오기
-        async function loadConfig() {
-            try {
-                const configData = await window.electronAPI.loadConfig();
-                // configData가 배열 형태라고 가정 ([{type:'int', ...}, ...])
-                settingsTableBody.innerHTML = ""; // 초기화
-                configData.forEach(rowData => {
-                    addRow(rowData);
-                });
-            } catch (e) {
-                console.error(e);
-            }
-        }
-
-        // 결과 불러오기
-        async function loadResults() {
-            try {
-                outputRetArea.textContent = '';
-                const retData = await window.electronAPI.loadResults();
-                console.log("retData", retData)
-                // configData가 배열 형태라고 가정 ([{type:'int', ...}, ...])
-                retData.forEach(rowData => {
-                    // output_ret 에 추가
-                    outputRetArea.textContent += rowData + '\n';
-                });
-            } catch (e) {
-                console.error(e);
-            }
-        }
-
-        // 테이블에 행 추가하는 함수
-        function addRow(rowData = null) {
-            const tr = document.createElement("tr");
-
-            // [수정] 1) - 버튼을 가운데 정렬, Bootstrap 버튼 스타일 적용
-            const tdRemove = document.createElement("td");
-            tdRemove.classList.add("text-center"); // 가운데 정렬
-            const removeBtn = document.createElement("button");
-            removeBtn.className = "remove-row-btn btn btn-sm btn-outline-danger";
-            removeBtn.textContent = "-";
-            removeBtn.addEventListener("click", () => {
-                tr.remove();
-            });
-            tdRemove.appendChild(removeBtn);
-            tr.appendChild(tdRemove);
-
-            // [수정] 2) 'Type' 셀의 select에 Bootstrap 폼 스타일 추가
-            const tdType = document.createElement("td");
-            const selectType = document.createElement("select");
-            selectType.classList.add("form-select"); // (Bootstrap select 스타일)
-            selectType.add(new Option("int", "int"));
-            selectType.add(new Option("float", "float"));
-            selectType.add(new Option("category", "category"));
-
-            // 기본값 설정
-            if (rowData && rowData.type) {
-                selectType.value = rowData.type;
-            }
-
-            // 타입 변화에 따라 동적 칸 재구성
-            selectType.addEventListener("change", () => {
-                renderDynamicCells(tr, selectType.value, rowData);
-            });
-
-            tdType.appendChild(selectType);
-            tr.appendChild(tdType);
-
-            // tr을 tbody에 붙인 뒤, 타입에 맞는 칸을 구성
-            settingsTableBody.appendChild(tr);
-            renderDynamicCells(tr, selectType.value, rowData);
-        }
-
-
-        function renderDynamicCells(tr, typeValue, rowData) {
-            // 타입 셀 뒤의 다른 셀들 제거 후 다시 생성
-            while (tr.cells.length > 2) {
-                tr.removeChild(tr.lastChild);
-            }
-            rowData = rowData || {};
-
-            if (typeValue === "int" || typeValue === "float") {
-                // (1) Name
-                const tdName = document.createElement("td");
-                const inputName = document.createElement("input");
-                inputName.classList.add("form-control"); // [수정] Bootstrap input 스타일
-                // 기존의 유효성 검사 관련 코드는 동일
-                registerBlurValidator(inputName, hasSpecialChar, '숫자, 알파벳 및 언더바(_) 만 허용됩니다.');
-                inputName.type = "text";
-                inputName.placeholder = "argument name";
-                if (rowData.name !== undefined) inputName.value = rowData.name;
-                tdName.appendChild(inputName);
-                tr.appendChild(tdName);
-
-                // (2) Min
-                const tdMin = document.createElement("td");
-                const inputMin = document.createElement("input");
-                inputMin.classList.add("form-control"); // [수정]
-                if (typeValue === "float") registerBlurValidator(inputMin, isNotFloat, 'float 형태여야 합니다!');
-                if (typeValue === "int") registerBlurValidator(inputMin, isNotInt, 'int 형태여야 합니다!');
-                inputMin.type = "text";
-                inputMin.placeholder = "min";
-                if (rowData.min !== undefined) inputMin.value = rowData.min;
-                tdMin.appendChild(inputMin);
-                tr.appendChild(tdMin);
-
-                // (3) Max
-                const tdMax = document.createElement("td");
-                const inputMax = document.createElement("input");
-                inputMax.classList.add("form-control"); // [수정]
-                if (typeValue === "float") registerBlurValidator(inputMax, isNotFloat, 'float 형태여야 합니다!');
-                if (typeValue === "int") registerBlurValidator(inputMax, isNotInt, 'int 형태여야 합니다!');
-                inputMax.type = "text";
-                inputMax.placeholder = "max";
-                if (rowData.max !== undefined) inputMax.value = rowData.max;
-                tdMax.appendChild(inputMax);
-                tr.appendChild(tdMax);
-
-                // (4) Step
-                const tdStep = document.createElement("td");
-                const inputStep = document.createElement("input");
-                inputStep.classList.add("form-control"); // [수정]
-                if (typeValue === "float") registerBlurValidator(inputStep, isNotFloat, 'float 형태여야 합니다!');
-                if (typeValue === "int") registerBlurValidator(inputStep, isNotInt, 'int 형태여야 합니다!');
-                inputStep.type = "text";
-                inputStep.placeholder = "step";
-                if (rowData.step !== undefined) inputStep.value = rowData.step;
-                tdStep.appendChild(inputStep);
-                tr.appendChild(tdStep);
-
-                // (5) Log Scale 여부
-                const tdLog = document.createElement("td");
-                const selectLog = document.createElement("select");
-                selectLog.classList.add("form-select"); // [수정]
-                selectLog.add(new Option("log scale", "log scale"));
-                selectLog.add(new Option("linear", "linear"));
-                selectLog.value = rowData.log || "linear";
-                tdLog.appendChild(selectLog);
-                tr.appendChild(tdLog);
-
-            } else if (typeValue === "category") {
-                // (1) Name
-                const tdName = document.createElement("td");
-                const inputName = document.createElement("input");
-                inputName.classList.add("form-control"); // [수정]
-                registerBlurValidator(inputName, hasSpecialChar, '숫자, 알파벳 및 언더바(_) 만 허용됩니다.');
-                inputName.type = "text";
-                inputName.placeholder = "argument name";
-                if (rowData.name !== undefined) inputName.value = rowData.name;
-                tdName.appendChild(inputName);
-                tr.appendChild(tdName);
-
-                // (2) Categories
-                const tdCat = document.createElement("td");
-                tdCat.colSpan = 4; // [기존] 4칸 합침
-                const inputCat = document.createElement("input");
-                inputCat.classList.add("form-control"); // [수정]
-                registerBlurValidator(inputCat, hasSpecialCharExComma, '숫자, 알파벳, 언더바(_), 콤마(,)만 허용됩니다.');
-                inputCat.type = "text";
-                inputCat.placeholder = "cat1,cat2,cat3";
-                if (rowData.categories !== undefined) inputCat.value = rowData.categories;
-                tdCat.appendChild(inputCat);
-                tr.appendChild(tdCat);
-            }
-        }
-
-
-        // 테이블 내용을 JSON 형태로 추출
-        function tableToJson() {
-            const rows = settingsTableBody.querySelectorAll("tr");
-            const result = [];
-
-            rows.forEach(tr => {
-                const cells = tr.querySelectorAll("td");
-                // 첫 번째 셀은 '-'버튼, 두 번째 셀은 'type' select
-                const typeSelect = cells[1].querySelector("select");
-                const typeValue = typeSelect.value;
-
-                let rowData = { type: typeValue };
-
-                if (typeValue === "int" || typeValue === "float") {
-                    // 4칸: min, max, step, log
-                    const inputName = cells[2].querySelector("input");
-                    const inputMin = cells[3].querySelector("input");
-                    const inputMax = cells[4].querySelector("input");
-                    const inputStep = cells[5].querySelector("input");
-                    const selectLog = cells[6].querySelector("select");
-
-                    rowData.name = inputName.value;
-                    rowData.min = inputMin.value;
-                    rowData.max = inputMax.value;
-                    rowData.step = inputStep.value;
-                    rowData.log = selectLog.value;
-                } else if (typeValue === "category") {
-                    // 1칸: categories
-                    // category 칸을 colspan=4 했다고 가정
-                    const inputName = cells[2].querySelector("input");
-                    const inputCat = cells[3].querySelector("input");
-                    rowData.name = inputName.value;
-                    rowData.categories = inputCat.value;
-                }
-
-                result.push(rowData);
-            });
-            return result;
-        }
-
-
-        /**
-        * 일정 시간(duration ms) 동안 화면에 메시지를 띄우고,
-        * 시간이 지나면 자동으로 제거하는 함수
-        */
-        function showTemporaryMessage(message, duration = 3000) {
-            const div = document.createElement('div');
-            div.textContent = message;
-            Object.assign(div.style, {
-                position: 'fixed',
-                top: '10px',
-                right: '10px',
-                backgroundColor: 'rgba(255, 0, 0, 0.7)',
-                color: '#fff',
-                padding: '10px',
-                borderRadius: '4px',
-                zIndex: 9999
-            });
-            document.body.appendChild(div);
-
-            setTimeout(() => {
-                div.remove();
-            }, duration);
-        }
-
-        /**
-        * 특정 input 요소(el)에 대해 blur 시 validatorFn을 검사.
-        * - 조건 실패 시, 3초 짜리 안내 메시지를 띄우고 focus를 다시 el로 이동
-        * - message: 조건이 안 맞을 때 띄울 안내문
-        */
-        function registerBlurValidator(el, validatorFn, message) {
-            el.addEventListener('blur', () => {
-                if (validatorFn(el.value) && el.value !== '') {
-                    // Blur 이벤트 직후에 곧바로 메시지를 띄우면 환경에 따라 포커스 문제가 생길 수 있으므로
-                    // setTimeout(…, 0)을 이용해 이벤트 루프가 한 번 돌고 난 뒤에 메시지를 띄움
-                    setTimeout(() => {
-                        showTemporaryMessage(message, 3000);
-                        el.value = ''; // 잘못된 값 제거
-                        el.focus();
-                    }, 0);
-                }
-            });
-        }
-
-        /**
-        * 1) 값이 float 이 아니면 true
-        * - JavaScript에서는 정수/실수 구분 없이 모두 Number지만,
-        * "유효한 실수 형태인가?"를 간단히 parseFloat 검사로 봅니다.
-        */
-        function isNotFloat(value) {
-            // case1) 이미 number 타입일 경우 → NaN이 아니면 float 가능
-            if (typeof value === 'number') {
-                return isNaN(value); // NaN이면 true, 아니면 false
-            }
-            // case2) 문자열인 경우
-            if (typeof value === 'string') {
-                // parseFloat 결과가 NaN이면 float 불가능
-                const parsed = parseFloat(value);
-                return isNaN(parsed);
-            }
-            // 그 외 타입은 float로 볼 수 없으니 true
-            return true;
-        }
-
-        /**
-        * 2) 값이 int 가 아니면 true
-        * - "정수 형태인가?"를 Number.isInteger로 검사
-        */
-        function isNotInt(value) {
-            // (1) 소수점 기호 '.' 이 문자열에 포함되어 있으면 "정수 아님"
-            if (typeof value === 'number') {
-                return !Number.isInteger(value); // 정수면 false, 아니면 true
-            }
-            if (typeof value === 'string') {
-                if (value.includes('.')) {
-                    return true;
-                }
-                const parsed = Number(value);
-                // parse가 NaN이 아니고 정수인지 확인
-                return isNaN(parsed) || !Number.isInteger(parsed);
-            }
-            // 그 외 타입은 int로 볼 수 없으니 true
-            return true;
-        }
-
-        /**
-        * 3) 값이 string 이 아니면 true
-        */
-        function isNotString(value) {
-            return typeof value !== 'string';
-        }
-
-        /**
-        * hasSpecialCharExceptUnderscore:
-        * '_'(언더스코어)를 제외한 특수문자가 하나라도 있으면 true
-        * - [0-9], [A-Za-z], '_' 이외의 어떤 문자라도 존재하면 true
-        */
-        function hasSpecialChar(value) {
-            const str = String(value);
-            // [^0-9A-Za-z_] : 허용되지 않은 문자들을 찾는 정규식
-            return /[^0-9A-Za-z_]/.test(str);
-        }
-
-        /**
-        * hasSpecialCharExceptUnderscore:
-        * '_'(언더스코어)를 제외한 특수문자가 하나라도 있으면 true
-        * - [0-9], [A-Za-z], '_', ',' 이외의 어떤 문자라도 존재하면 true
-        */
-        function hasSpecialCharExComma(value) {
-            const str = String(value);
-            // [^0-9A-Za-z_,] : 허용되지 않은 문자들을 찾는 정규식
-            return /[^0-9A-Za-z_,]/.test(str);
-        }
-
-    </script>
-</body>
-
-</html>
\ No newline at end of file
diff --git a/project/index.html b/project/index.html
index 26fbe53..45e14a4 100644
--- a/project/index.html
+++ b/project/index.html
@@ -13,6 +13,8 @@
         body {
             margin: 0;
             font-family: sans-serif;
+            background-color: #1e1e1e;
+            color: #e0e0e0;
         }
 
         .tab-content {
@@ -24,6 +26,173 @@
             display: block;
             /* 선택된 탭은 보이게 */
         }
+
+        .image-container {
+            display: grid;
+            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
+            gap: 10px;
+            margin-top: 10px;
+        }
+
+        .image-container img {
+            width: 100%;
+            height: auto;
+            object-fit: contain;
+            border: 1px solid #444;
+        }
+
+        .folder-path {
+            font-weight: bold;
+            margin-top: 10px;
+            margin-bottom: 5px;
+            color: #e0e0e0;
+        }
+
+        .step-title {
+            font-weight: bold;
+            text-align: center;
+            margin-bottom: 10px;
+            color: #e0e0e0;
+        }
+
+        /* Dark mode styles for Bootstrap components */
+        .table {
+            color: #e0e0e0;
+            background-color: #2d2d2d;
+        }
+
+        .table-bordered {
+            border-color: #444;
+        }
+
+        .table-secondary {
+            background-color: #2d2d2d;
+            color: #e0e0e0;
+        }
+
+        .table thead th {
+            background-color: #333;
+            color: #e0e0e0;
+            border-color: #444;
+        }
+
+        .table tbody td {
+            background-color: #2d2d2d;
+            border-color: #444;
+        }
+
+        .table-bordered td,
+        .table-bordered th {
+            border-color: #444;
+        }
+
+        .form-control,
+        .form-select {
+            background-color: #2d2d2d;
+            border-color: #444;
+            color: #e0e0e0;
+        }
+
+        .form-control:focus,
+        .form-select:focus {
+            background-color: #2d2d2d;
+            border-color: #666;
+            color: #e0e0e0;
+            box-shadow: 0 0 0 0.25rem rgba(255, 255, 255, 0.1);
+        }
+
+        /* Button styles for dark mode */
+        .btn-warning {
+            background-color: #ffc107;
+            border-color: #ffc107;
+            color: #1e1e1e;
+        }
+
+        .btn-warning:hover {
+            background-color: #ffca2c;
+            border-color: #ffc720;
+            color: #1e1e1e;
+        }
+
+        .btn-success {
+            background-color: #198754;
+            border-color: #198754;
+            color: #fff;
+        }
+
+        .btn-success:hover {
+            background-color: #157347;
+            border-color: #146c43;
+            color: #fff;
+        }
+
+        .btn-primary {
+            background-color: #0d6efd;
+            border-color: #0d6efd;
+            color: #fff;
+        }
+
+        .btn-primary:hover {
+            background-color: #0b5ed7;
+            border-color: #0a58ca;
+            color: #fff;
+        }
+
+        .btn-info {
+            background-color: #0dcaf0;
+            border-color: #0dcaf0;
+            color: #1e1e1e;
+        }
+
+        .btn-info:hover {
+            background-color: #31d2f2;
+            border-color: #25cff2;
+            color: #1e1e1e;
+        }
+
+        .btn-outline-danger {
+            color: #ff6b6b;
+            border-color: #ff6b6b;
+        }
+
+        .btn-outline-danger:hover {
+            background-color: #ff6b6b;
+            color: #1e1e1e;
+        }
+
+        /* IQGen specific styles */
+        .step-container {
+            background-color: #2d2d2d;
+            border: 1px solid #444;
+            border-radius: 5px;
+            padding: 15px;
+            height: 100%;
+        }
+
+        .image-column {
+            background-color: #2d2d2d;
+            border: 1px solid #444;
+            border-radius: 5px;
+            margin: 5px;
+            padding: 10px;
+        }
+
+        .progress {
+            background-color: #444;
+        }
+
+        .progress-bar {
+            background-color: #0d6efd;
+        }
+
+        h1 {
+            color: #e0e0e0;
+        }
+
+        /* Webview styles */
+        webview {
+            background-color: #1e1e1e;
+        }
     </style>
 </head>
 
@@ -106,7 +275,9 @@
                 -->
                 <button class="btn btn-warning w-100 d-block mx-auto mb-2" id="btnSettings">Settings</button>
                 <!-- 기존 버튼들 아래에 Dashboard 버튼 하나 추가 -->
-                <button class="btn btn-success w-100 d-block mx-auto mt-2" id="btnDashboard">Dashboard</button>
+                <button class="btn btn-success w-100 d-block mx-auto mt-2 mb-2" id="btnDashboard">Dashboard</button>
+                <!-- IQGen 버튼 추가 -->
+                <button class="btn btn-primary w-100 d-block mx-auto mt-2" id="btnIQGen">IQGen</button>
             </div>
 
             <!-- 오른쪽 컨텐츠: 남은 공간(col) -->
@@ -203,6 +374,10 @@
                 <div id="dashboardTab" class="tab-content">
                 </div>
 
+                <!-- IQGen Tab -->
+                <div id="iqgenTab" class="tab-content">
+                </div>
+
             </div> <!-- col 끝 -->
         </div> <!-- row 끝 -->
     </div> <!-- container-fluid 끝 -->
@@ -211,13 +386,16 @@
         // 탭 전환 로직
         const btnSettings = document.getElementById("btnSettings");
         const btnDashboard = document.getElementById("btnDashboard");
+        const btnIQGen = document.getElementById("btnIQGen");
         const settingsTab = document.getElementById("settingsTab");
         const dashboardTab = document.getElementById("dashboardTab");
+        const iqgenTab = document.getElementById("iqgenTab");
 
 
         btnSettings.addEventListener("click", async () => {
             settingsTab.classList.add("active");
             dashboardTab.classList.remove("active");
+            iqgenTab.classList.remove("active");
             // 설정 탭 들어갈 때마다 config.json 불러오기
             await loadConfig();
         });
@@ -227,6 +405,7 @@
         btnDashboard.addEventListener("click", async () => {
             settingsTab.classList.remove("active");
             dashboardTab.classList.add("active");
+            iqgenTab.classList.remove("active");
             // 1) dashboardTab 내부의 기존 webview가 있으면 제거 (이미 만들어진 적이 있으면)
             const existingWebview = document.querySelector('#dashboardTab webview');
             if (existingWebview) {
@@ -255,7 +434,76 @@
             //webview.addEventListener('dom-ready', () => {
             //    webview.openDevTools(); // webview 는 개발자 도구를 따로 사용하므로, 필요하다면 여기서 열어줘야 함.
             //});
+        });
+
+        // IQGen 버튼 클릭 시 탭 전환 및 iqgen.html 로드
+        btnIQGen.addEventListener("click", async () => {
+            settingsTab.classList.remove("active");
+            dashboardTab.classList.remove("active");
+            iqgenTab.classList.add("active");
+
+            // 기존 webview가 있는지 확인
+            const existingWebview = document.querySelector('#iqgenTab webview');
+
+            // 이미 웹뷰가 존재하고 정상적으로 로드된 상태라면 유지
+            if (existingWebview && existingWebview.getURL && existingWebview.getURL().includes('iqgen.html')) {
+                console.log('IQGen webview already exists, just sending focus');
+                try {
+                    // 웹뷰가 있으면 이미 있는 웹뷰에 focus 이벤트를 보내서 다시 활성화
+                    existingWebview.send('tab:focus');
+                } catch (error) {
+                    console.error('Error sending focus event to existing webview:', error);
+                }
+                return;
+            }
 
+            // 기존 웹뷰 제거 (있는 경우)
+            if (existingWebview) {
+                existingWebview.remove();
+            }
+
+            try {
+                // Webview를 동적으로 생성
+                const webview = document.createElement('webview');
+
+                // 동적 경로(preloadAbsolutePath) 가져오기
+                const preloadAbsolutePath = await window.electronAPI.getIQGenPreloadPath();
+                console.log("IQGen preload path:", preloadAbsolutePath);
+
+                // Webview 속성 설정
+                webview.setAttribute('preload', preloadAbsolutePath);
+                webview.setAttribute('src', 'iqgen.html');
+                webview.style.width = '100%';
+                webview.style.height = '800px';
+                webview.style.border = 'none';
+
+                // 디버깅을 위한 이벤트 리스너 추가
+                webview.addEventListener('dom-ready', () => {
+                    console.log('IQGen webview DOM is ready');
+                    // 웹뷰 초기화 완료 후 탭 전환 이벤트 전송
+                    try {
+                        webview.send('tab:activated');
+                    } catch (error) {
+                        console.error('Error sending activation event to webview:', error);
+                    }
+                    // 개발 중에는 webview의 개발자 도구를 열어 디버깅
+                    // webview.openDevTools();
+                });
+
+                webview.addEventListener('did-fail-load', (e) => {
+                    console.error('Webview failed to load:', e);
+                });
+
+                webview.addEventListener('console-message', (e) => {
+                    console.log('Webview console message:', e.message);
+                });
+
+                // iqgenTab div에 삽입
+                iqgenTab.appendChild(webview);
+            } catch (error) {
+                console.error("Error loading IQGen tab:", error);
+                alert("IQGen 탭을 로드하는 중 오류가 발생했습니다: " + error.message);
+            }
         });
 
         // ---------------------
@@ -508,8 +756,7 @@
         function registerBlurValidator(el, validatorFn, message) {
             el.addEventListener('blur', () => {
                 if (validatorFn(el.value) && el.value !== '') {
-                    // Blur 이벤트 직후에 곧바로 메시지를 띄우면 환경에 따라 포커스 문제가 생길 수 있으므로
-                    // setTimeout(…, 0)을 이용해 이벤트 루프가 한 번 돌고 난 뒤에 메시지를 띄움
+                    // Blur 이벤트 직후에 곧바로 메시지를 띄움
                     setTimeout(() => {
                         showTemporaryMessage(message, 3000);
                         el.value = ''; // 잘못된 값 제거
diff --git a/project/index_bulma.html b/project/index_bulma.html
deleted file mode 100644
index 054b552..0000000
--- a/project/index_bulma.html
+++ /dev/null
@@ -1,669 +0,0 @@
-<!DOCTYPE html>
-<html lang="ko">
-
-<head>
-    <meta charset="UTF-8" />
-    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
-    <title>Electron App with Tabs</title>
-
-    <!-- Bulma CSS CDN -->
-    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.4/css/bulma.min.css">
-
-
-    <style>
-        body {
-            margin: 0;
-            font-family: sans-serif;
-        }
-
-        /* 전체 레이아웃: 왼쪽 사이드바, 오른쪽 컨텐츠 */
-        .container {
-            display: flex;
-            height: 100vh;
-        }
-
-        .sidebar {
-            width: 100px;
-            background-color: #f0f0f0;
-            border-right: 1px solid #ccc;
-            display: flex;
-            flex-direction: column;
-            padding: 10px;
-        }
-
-        .sidebar button {
-            margin-bottom: 10px;
-            padding: 10px;
-            cursor: pointer;
-            border: 1px solid #ccc;
-            background-color: #fff;
-        }
-
-        .sidebar button:hover {
-            background-color: #ddd;
-        }
-
-        .content {
-            flex-grow: 1;
-            padding: 20px;
-            overflow: auto;
-        }
-
-        .tab-content {
-            display: none;
-            /* 기본적으로 감춰놓고, 선택된 탭만 표시 */
-        }
-
-        .tab-content.active {
-            display: block;
-            /* 선택된 탭은 보이게 */
-        }
-
-        /* 메인 탭 스타일 */
-        .input-group {
-            display: flex;
-            align-items: center;
-            margin-bottom: 10px;
-        }
-
-        .input-group input {
-            width: 400px;
-            /* 입력창 너비 조정 */
-            padding: 8px;
-            font-size: 16px;
-            flex-grow: 1;
-        }
-
-        .input-group button {
-            margin-left: 10px;
-            padding: 8px 12px;
-            font-size: 16px;
-            cursor: pointer;
-        }
-
-        #output {
-            white-space: pre-wrap;
-            /* 줄바꿈 & 공백 보이기 */
-            background-color: #eee;
-            padding: 10px;
-            margin-top: 20px;
-            border: 1px solid #ccc;
-        }
-
-        /* 설정 탭 스타일 */
-        #settingsTable {
-            border-collapse: collapse;
-            width: 100%;
-            margin-bottom: 10px;
-            /*table-layout: fixed;*/
-        }
-
-        #settingsTable th,
-        #settingsTable td {
-            border: 1px solid #ccc;
-            padding: 5px;
-        }
-
-        #settingsTable th {
-            background-color: #f9f9f9;
-        }
-
-        .remove-row-btn {
-            background-color: #ffdddd;
-            border: 1px solid #ccc;
-            cursor: pointer;
-        }
-
-        .add-row-btn {
-            margin-bottom: 10px;
-            padding: 8px;
-            font-size: 16px;
-            cursor: pointer;
-        }
-
-        .hidden {
-            display: none;
-        }
-
-        /* 기존에 있던 th, td 스타일 등은 그대로 두고, 첫 번째 열(- 박스들)만 가운데 정렬 추가 */
-        #settingsTable td:nth-child(1),
-        #settingsTable th:nth-child(1) {
-            text-align: center;
-        }
-
-        /* 테이블 내의 모든 <input>에 99% 너비 적용 */
-        #settingsTable input {
-            width: 99.5%;
-            box-sizing: border-box;
-            /* 테두리/패딩 포함해서 계산(권장) */
-        }
-
-        /* 테이블 내의 모든 <select>에 99% 너비 적용 */
-        #settingsTable select {
-            width: 99.5%;
-            box-sizing: border-box;
-            /* 테두리/패딩 포함해서 계산(권장) */
-        }
-    </style>
-</head>
-
-<body>
-    <div class="container">
-        <!-- 왼쪽 사이드바 (column is-narrow) -->
-        <div class="column is-narrow has-background-light p-3" style="border-right: 1px solid #ccc;">
-            <button class="button is-fullwidth mb-2" id="btnMain">메인</button>
-            <button class="button is-fullwidth mb-2" id="btnSettings">설정</button>
-            <button class="button is-fullwidth" id="btnResults">결과</button>
-        </div>
-
-        <!-- 오른쪽 컨텐츠 영역 -->
-        <div class="content">
-            <!-- 메인 탭 내용 -->
-            <div id="mainTab" class="tab-content active">
-                <h1 class="title is-4">Run local command</h1>
-                <div class="field has-addons mb-3">
-                    <div class="control is-expanded">
-                        <input class="input" type="text" id="command"
-                            placeholder="Python path (e.g. /home/run/pyenv/bin/python)" />
-                    </div>
-                    <div class="control">
-                        <button class="button" onclick="selectFile('command')">Browse</button>
-                    </div>
-                </div>
-                <div class="field has-addons mb-3">
-                    <div class="control is-expanded">
-                        <input class="input" type="text" id="args" placeholder="Optuna path (e.g. /home/run/main.py)" />
-                    </div>
-                    <div class="control">
-                        <button class="button" onclick="selectFile('args')">Browse</button>
-                    </div>
-                </div>
-                <button class="button is-primary" id="runBtn">Run</button>
-                <pre id="output" class="mt-3 p-3 has-background-light" style="border: 1px solid #ccc;"></pre>
-            </div>
-
-            <!-- 설정 탭 내용 -->
-            <div id="settingsTab" class="tab-content">
-                <h1 class="title is-4">설정</h1>
-                <button class="button mb-3" id="addRowBtn">+ 행 추가</button>
-                <table id="settingsTable" class="table is-fullwidth is-bordered is-hoverable">
-                    <thead>
-                        <tr>
-                            <th>-</th>
-                            <th>Type</th>
-                            <th>Name</th>
-                            <th colspan="4">Config</th>
-                        </tr>
-                    </thead>
-                    <tbody>
-                        <!-- 동적 행 추가 영역 -->
-                    </tbody>
-                </table>
-                <div>
-                    <button class="button is-success" id="saveBtn">저장</button>
-                    <button class="button is-warning" id="resetBtn">초기화</button>
-                </div>
-            </div>
-
-            <!-- 결과 탭 내용 -->
-            <div id="resultsTab" class="tab-content">
-                <h1 class="title is-4">결과</h1>
-                <pre id="output_ret" class="p-3 has-background-light" style="border: 1px solid #ccc;"></pre>
-            </div>
-        </div>
-    </div>
-
-    <script>
-        // 탭 전환 로직
-        const btnMain = document.getElementById("btnMain");
-        const btnSettings = document.getElementById("btnSettings");
-        const btnResults = document.getElementById("btnResults");
-        const mainTab = document.getElementById("mainTab");
-        const settingsTab = document.getElementById("settingsTab");
-        const resultsTab = document.getElementById("resultsTab");
-
-        btnMain.addEventListener("click", () => {
-            mainTab.classList.add("active");
-            settingsTab.classList.remove("active");
-            resultsTab.classList.remove("active");
-        });
-        btnSettings.addEventListener("click", async () => {
-            mainTab.classList.remove("active");
-            settingsTab.classList.add("active");
-            resultsTab.classList.remove("active");
-            // 설정 탭 들어갈 때마다 config.json 불러오기
-            await loadConfig();
-        });
-        btnResults.addEventListener("click", async () => {
-            mainTab.classList.remove("active");
-            settingsTab.classList.remove("active");
-            resultsTab.classList.add("active");
-            // 결과 탭 들어갈 때마다 결과 불러오기
-            await loadResults();
-        });
-
-        // ---------------------
-        // 메인 탭 (기존 기능)
-        // ---------------------
-        const runBtn = document.getElementById('runBtn');
-        const cmdInput = document.getElementById('command');
-        const argsInput = document.getElementById('args');
-        const outputArea = document.getElementById('output');
-        const outputRetArea = document.getElementById('output_ret');
-
-        // =============== 실시간 로그를 뿌릴 이벤트 연결 ===============
-        // main -> renderer 통신
-        window.electronAPI.onCommandStdout((data) => {
-            outputArea.textContent += data;  // 그냥 이어붙이면 됨
-        });
-
-        window.electronAPI.onCommandStderr((data) => {
-            // outputArea.textContent += '[ERR] ' + data; // 현재는 에러는 표시 안함
-        });
-
-        window.electronAPI.onCommandClose((code) => {
-            outputArea.textContent += `\n--- Process exited with code: ${code} ---\n`;
-        });
-
-        window.electronAPI.onCommandError((errMsg) => {
-            outputArea.textContent += `[ERROR] ${errMsg}\n`;
-        });
-        // ============================================================
-
-        runBtn.addEventListener('click', async () => {
-            const cmd = cmdInput.value.trim();
-            // 공백으로 구분된 인자를 배열로
-            const args = argsInput.value.trim().split(' ');
-
-            outputArea.textContent = 'Running command...\n';
-
-            try {
-                // 프로세스 시작
-                const result = await window.electronAPI.runCommand(cmd, args);
-                // 여기 도달 시점: 프로세스가 종료된 뒤
-                outputArea.textContent += `\nProcess ended. code=${result.code}\n`;
-            } catch (err) {
-                outputArea.textContent += `\n[ERROR] ${err.message}\n`;
-            }
-        });
-
-
-        function selectFile(inputId) {
-            const inputElement = document.getElementById(inputId);
-            const fileInput = document.createElement("input");
-            fileInput.type = "file";
-            fileInput.style.display = "none";
-
-            fileInput.onchange = function (event) {
-                if (event.target.files.length > 0) {
-                    inputElement.value = event.target.files[0].path;
-                }
-            };
-
-            document.body.appendChild(fileInput);
-            fileInput.click();
-            document.body.removeChild(fileInput);
-        }
-
-        // ---------------------
-        // 설정 탭
-        // ---------------------
-        const addRowBtn = document.getElementById("addRowBtn");
-        const saveBtn = document.getElementById("saveBtn");
-        const resetBtn = document.getElementById("resetBtn");
-        const settingsTableBody = document.querySelector("#settingsTable tbody");
-
-        // 행 추가 버튼 클릭 시
-        addRowBtn.addEventListener("click", () => {
-            addRow();
-        });
-
-        // 초기화 버튼 클릭 시
-        resetBtn.addEventListener("click", () => {
-            settingsTableBody.innerHTML = ""; // 테이블 초기화
-        });
-
-        // 저장 버튼 클릭 시
-        saveBtn.addEventListener("click", async () => {
-            // 테이블 내용을 JSON 형태로 추출
-            const data = tableToJson();
-            // IPC로 main process에 저장 요청
-            await window.electronAPI.saveConfig(data);
-            alert("저장 완료!");
-        });
-
-        // 설정 탭 들어갈 때 불러오기
-        async function loadConfig() {
-            try {
-                const configData = await window.electronAPI.loadConfig();
-                // configData가 배열 형태라고 가정 ([{type:'int', ...}, ...])
-                settingsTableBody.innerHTML = ""; // 초기화
-                configData.forEach(rowData => {
-                    addRow(rowData);
-                });
-            } catch (e) {
-                console.error(e);
-            }
-        }
-
-        // 결과 불러오기
-        async function loadResults() {
-            try {
-                outputRetArea.textContent = '';
-                const retData = await window.electronAPI.loadResults();
-                console.log("retData", retData)
-                // configData가 배열 형태라고 가정 ([{type:'int', ...}, ...])
-                retData.forEach(rowData => {
-                    // output_ret 에 추가
-                    outputRetArea.textContent += rowData + '\n';
-                });
-            } catch (e) {
-                console.error(e);
-            }
-        }
-
-        // 테이블에 행 추가하는 함수
-        function addRow(rowData = null) {
-            /* rowData = {
-                 type: 'int'|'float'|'category',
-                 min: ...,
-                 max: ...,
-                 step: ...,
-                 log: 'Log scale'|'Linear',
-                 categories: 'cat1,cat2,...'
-               } 
-               또는 없는 경우(초기)는 null
-            */
-
-            const tr = document.createElement("tr");
-
-            // 1) 삭제 버튼 셀
-            const tdRemove = document.createElement("td");
-            const removeBtn = document.createElement("button");
-            removeBtn.className = "remove-row-btn";
-            removeBtn.textContent = "-";
-            removeBtn.addEventListener("click", () => {
-                tr.remove();
-            });
-            tdRemove.appendChild(removeBtn);
-            tr.appendChild(tdRemove);
-
-            // 2) 타입 선택 셀
-            const tdType = document.createElement("td");
-            const selectType = document.createElement("select");
-            const optionInt = new Option("int", "int");
-            const optionFloat = new Option("float", "float");
-            const optionCategory = new Option("category", "category");
-
-            selectType.add(optionInt);
-            selectType.add(optionFloat);
-            selectType.add(optionCategory);
-
-            // 기본값 설정
-            if (rowData && rowData.type) {
-                selectType.value = rowData.type;
-            }
-
-            // 타입 변화시 동적으로 다음 칸들 구성 변경
-            selectType.addEventListener("change", () => {
-                renderDynamicCells(tr, selectType.value, rowData);
-            });
-
-            tdType.appendChild(selectType);
-            tr.appendChild(tdType);
-
-            // 우선 tr을 tbody에 추가해놓고, 타입에 맞는 칸을 그리도록
-            settingsTableBody.appendChild(tr);
-
-            // 타입에 맞는 동적 칸 그리기
-            renderDynamicCells(tr, selectType.value, rowData);
-        }
-
-        function renderDynamicCells(tr, typeValue, rowData) {
-            // 타입 셀 뒤에 존재하는 다른 셀들은 모두 제거한 뒤 다시 생성
-            // (int/float/category 중 변경 가능하므로)
-            // 첫 번째(tdRemove) + 두 번째(tdType) 셀을 제외하고 모두 제거
-            while (tr.cells.length > 2) {
-                tr.removeChild(tr.lastChild);
-            }
-
-            // rowData가 없다면 새로 추가. 있으면 해당 값 활용
-            rowData = rowData || {};
-
-            if (typeValue === "int" || typeValue === "float") {
-                // 이름
-                const tdName = document.createElement("td");
-                const inputName = document.createElement("input");
-                registerBlurValidator(inputName, hasSpecialChar, '숫자, 알파벳 및 언더바(_) 만 허용됩니다.');
-                inputName.type = "text";
-                inputName.placeholder = "argument name";
-                if (rowData.name !== undefined) inputName.value = rowData.name;
-                tdName.appendChild(inputName);
-                tr.appendChild(tdName);
-
-                // 최소값
-                const tdMin = document.createElement("td");
-                const inputMin = document.createElement("input");
-                if (typeValue === "float") registerBlurValidator(inputMin, isNotFloat, '값은 float 이어야 합니다!');
-                if (typeValue === "int") registerBlurValidator(inputMin, isNotInt, '값은 마침표(.) 가 없는 int 이어야 합니다!');
-                inputMin.type = "text";
-                inputMin.placeholder = "min";
-                if (rowData.min !== undefined) inputMin.value = rowData.min;
-                tdMin.appendChild(inputMin);
-                tr.appendChild(tdMin);
-
-                // 최대값
-                const tdMax = document.createElement("td");
-                const inputMax = document.createElement("input");
-                if (typeValue === "float") registerBlurValidator(inputMax, isNotFloat, '값은 float 이어야 합니다!');
-                if (typeValue === "int") registerBlurValidator(inputMax, isNotInt, '값은 마침표(.) 가 없는 int 이어야 합니다!');
-                inputMax.type = "text";
-                inputMax.placeholder = "max";
-                if (rowData.max !== undefined) inputMax.value = rowData.max;
-                tdMax.appendChild(inputMax);
-                tr.appendChild(tdMax);
-
-                // 스텝값
-                const tdStep = document.createElement("td");
-                const inputStep = document.createElement("input");
-                if (typeValue === "float") registerBlurValidator(inputStep, isNotFloat, '값은 float 이어야 합니다!');
-                if (typeValue === "int") registerBlurValidator(inputStep, isNotInt, '값은 마침표(.) 가 없는 int 이어야 합니다!');
-                inputStep.type = "text";
-                inputStep.placeholder = "step";
-                if (rowData.step !== undefined) inputStep.value = rowData.step;
-                tdStep.appendChild(inputStep);
-                tr.appendChild(tdStep);
-
-                // Log 여부
-                const tdLog = document.createElement("td");
-                const selectLog = document.createElement("select");
-                selectLog.add(new Option("log scale"));
-                selectLog.add(new Option("linear"));
-                // selectLog.add(new Option("Log scale", "Linear"));
-                // 기본값
-                selectLog.value = rowData.log || "linear";
-                tdLog.appendChild(selectLog);
-                tr.appendChild(tdLog);
-            }
-            else if (typeValue === "category") {
-                // 이름
-                const tdName = document.createElement("td");
-                const inputName = document.createElement("input");
-                registerBlurValidator(inputName, hasSpecialChar, '숫자, 알파벳 및 언더바(_) 만 허용됩니다.');
-                inputName.type = "text";
-                inputName.placeholder = "argument name";
-                if (rowData.name !== undefined) inputName.value = rowData.name;
-                tdName.appendChild(inputName);
-                tr.appendChild(tdName);
-
-                // , 로 구분되는 하나의 string
-                const tdCat = document.createElement("td");
-                const inputCat = document.createElement("input");
-                tdCat.colSpan = 4; // int/float 대비해서 4칸을 합쳐도 됨(선택사항)
-                registerBlurValidator(inputCat, hasSpecialCharExComma, '숫자, 알파벳, 언더바(_) 및 콤마(,) 만 허용됩니다.');
-                inputCat.type = "text";
-                inputCat.placeholder = "cat1,cat2,cat3";
-                if (rowData.categories !== undefined) inputCat.value = rowData.categories;
-                tdCat.appendChild(inputCat);
-                tr.appendChild(tdCat);
-            }
-        }
-
-        // 테이블 내용을 JSON 형태로 추출
-        function tableToJson() {
-            const rows = settingsTableBody.querySelectorAll("tr");
-            const result = [];
-
-            rows.forEach(tr => {
-                const cells = tr.querySelectorAll("td");
-                // 첫 번째 셀은 '-'버튼, 두 번째 셀은 'type' select
-                const typeSelect = cells[1].querySelector("select");
-                const typeValue = typeSelect.value;
-
-                let rowData = { type: typeValue };
-
-                if (typeValue === "int" || typeValue === "float") {
-                    // 4칸: min, max, step, log
-                    const inputName = cells[2].querySelector("input");
-                    const inputMin = cells[3].querySelector("input");
-                    const inputMax = cells[4].querySelector("input");
-                    const inputStep = cells[5].querySelector("input");
-                    const selectLog = cells[6].querySelector("select");
-
-                    rowData.name = inputName.value;
-                    rowData.min = inputMin.value;
-                    rowData.max = inputMax.value;
-                    rowData.step = inputStep.value;
-                    rowData.log = selectLog.value;
-                } else if (typeValue === "category") {
-                    // 1칸: categories
-                    // category 칸을 colspan=4 했다고 가정
-                    const inputName = cells[2].querySelector("input");
-                    const inputCat = cells[3].querySelector("input");
-                    rowData.name = inputName.value;
-                    rowData.categories = inputCat.value;
-                }
-
-                result.push(rowData);
-            });
-            return result;
-        }
-
-
-        /**
-         * 일정 시간(duration ms) 동안 화면에 메시지를 띄우고,
-         * 시간이 지나면 자동으로 제거하는 함수
-         */
-        function showTemporaryMessage(message, duration = 3000) {
-            const div = document.createElement('div');
-            div.textContent = message;
-            Object.assign(div.style, {
-                position: 'fixed',
-                top: '10px',
-                right: '10px',
-                backgroundColor: 'rgba(255, 0, 0, 0.7)',
-                color: '#fff',
-                padding: '10px',
-                borderRadius: '4px',
-                zIndex: 9999
-            });
-            document.body.appendChild(div);
-
-            setTimeout(() => {
-                div.remove();
-            }, duration);
-        }
-
-        /**
-         * 특정 input 요소(el)에 대해 blur 시 validatorFn을 검사.
-         * - 조건 실패 시, 3초 짜리 안내 메시지를 띄우고 focus를 다시 el로 이동
-         * - message: 조건이 안 맞을 때 띄울 안내문
-         */
-        function registerBlurValidator(el, validatorFn, message) {
-            el.addEventListener('blur', () => {
-                if (validatorFn(el.value) && el.value !== '') {
-                    // Blur 이벤트 직후에 곧바로 메시지를 띄우면 환경에 따라 포커스 문제가 생길 수 있으므로
-                    // setTimeout(…, 0)을 이용해 이벤트 루프가 한 번 돌고 난 뒤에 메시지를 띄움
-                    setTimeout(() => {
-                        showTemporaryMessage(message, 3000);
-                        el.value = ''; // 잘못된 값 제거
-                        el.focus();
-                    }, 0);
-                }
-            });
-        }
-
-        /**
-         * 1) 값이 float 이 아니면 true
-         *  - JavaScript에서는 정수/실수 구분 없이 모두 Number지만,
-         *    "유효한 실수 형태인가?"를 간단히 parseFloat 검사로 봅니다.
-         */
-        function isNotFloat(value) {
-            // case1) 이미 number 타입일 경우 → NaN이 아니면 float 가능
-            if (typeof value === 'number') {
-                return isNaN(value); // NaN이면 true, 아니면 false
-            }
-            // case2) 문자열인 경우
-            if (typeof value === 'string') {
-                // parseFloat 결과가 NaN이면 float 불가능
-                const parsed = parseFloat(value);
-                return isNaN(parsed);
-            }
-            // 그 외 타입은 float로 볼 수 없으니 true
-            return true;
-        }
-
-        /**
-        * 2) 값이 int 가 아니면 true
-        *  - "정수 형태인가?"를 Number.isInteger로 검사
-        */
-        function isNotInt(value) {
-            // (1) 소수점 기호 '.' 이 문자열에 포함되어 있으면 "정수 아님"
-            if (typeof value === 'number') {
-                return !Number.isInteger(value); // 정수면 false, 아니면 true
-            }
-            if (typeof value === 'string') {
-                if (value.includes('.')) {
-                    return true;
-                }
-                const parsed = Number(value);
-                // parse가 NaN이 아니고 정수인지 확인
-                return isNaN(parsed) || !Number.isInteger(parsed);
-            }
-            // 그 외 타입은 int로 볼 수 없으니 true
-            return true;
-        }
-
-        /**
-        * 3) 값이 string 이 아니면 true
-        */
-        function isNotString(value) {
-            return typeof value !== 'string';
-        }
-
-        /**
-         * hasSpecialCharExceptUnderscore:
-         *   '_'(언더스코어)를 제외한 특수문자가 하나라도 있으면 true
-         *   - [0-9], [A-Za-z], '_' 이외의 어떤 문자라도 존재하면 true
-         */
-        function hasSpecialChar(value) {
-            const str = String(value);
-            // [^0-9A-Za-z_] : 허용되지 않은 문자들을 찾는 정규식
-            return /[^0-9A-Za-z_]/.test(str);
-        }
-
-        /**
-         * hasSpecialCharExceptUnderscore:
-         *   '_'(언더스코어)를 제외한 특수문자가 하나라도 있으면 true
-         *   - [0-9], [A-Za-z], '_', ',' 이외의 어떤 문자라도 존재하면 true
-         */
-        function hasSpecialCharExComma(value) {
-            const str = String(value);
-            // [^0-9A-Za-z_,] : 허용되지 않은 문자들을 찾는 정규식
-            return /[^0-9A-Za-z_,]/.test(str);
-        }
-
-    </script>
-</body>
-
-</html>
\ No newline at end of file
diff --git a/project/iqgen.html b/project/iqgen.html
new file mode 100644
index 0000000..e67e163
--- /dev/null
+++ b/project/iqgen.html
@@ -0,0 +1,1522 @@
+<!DOCTYPE html>
+<html lang="en">
+
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>IQGen</title>
+    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
+    <style>
+        body {
+            font-family: sans-serif;
+            padding: 20px;
+            background-color: #1e1e1e;
+            color: #e0e0e0;
+        }
+
+        .top-row {
+            margin-bottom: 20px;
+        }
+
+        .step-container {
+            border: 1px solid #444;
+            border-radius: 5px;
+            padding: 15px;
+            height: 100%;
+            background-color: #2d2d2d;
+        }
+
+        .step-title {
+            font-weight: bold;
+            text-align: center;
+            margin-bottom: 10px;
+            color: #e0e0e0;
+        }
+
+        .progress {
+            height: 20px;
+            margin-bottom: 15px;
+            background-color: #444;
+        }
+
+        .progress-bar {
+            background-color: #0d6efd;
+        }
+
+        .bottom-row {
+            display: flex;
+            flex-wrap: wrap;
+        }
+
+        /* Custom 1.5 column width for 8 column layout */
+        .col-xl-1-5 {
+            flex: 0 0 12.5%;
+            max-width: 12.5%;
+        }
+
+        .image-column {
+            flex: 1;
+            min-width: 150px;
+            padding: 1px;
+            border: 1px solid #444;
+            border-radius: 5px;
+            margin: 5px;
+            background-color: #2d2d2d;
+        }
+
+        .folder-path {
+            font-weight: bold;
+            margin-bottom: 10px;
+            text-align: center;
+            color: #e0e0e0;
+            font-size: 0.85rem;
+        }
+
+        .folder-path button {
+            margin-top: 5px;
+        }
+
+        .image-container {
+            display: grid;
+            grid-template-columns: 1fr;
+            gap: 1px;
+            justify-items: center;
+        }
+
+        .image-container img {
+            width: 190px;
+            height: 190px;
+            object-fit: fill;
+            border: 1px solid #444;
+        }
+
+        .btn-help {
+            margin-left: 10px;
+        }
+
+        /* Form controls */
+        .form-control,
+        .form-select {
+            background-color: #2d2d2d;
+            border-color: #444;
+            color: #e0e0e0;
+        }
+
+        .form-control:focus,
+        .form-select:focus {
+            background-color: #2d2d2d;
+            border-color: #666;
+            color: #e0e0e0;
+            box-shadow: 0 0 0 0.25rem rgba(255, 255, 255, 0.1);
+        }
+
+        /* Button styles */
+        .btn-warning {
+            background-color: #ffc107;
+            border-color: #ffc107;
+            color: #1e1e1e;
+        }
+
+        .btn-warning:hover {
+            background-color: #ffca2c;
+            border-color: #ffc720;
+            color: #1e1e1e;
+        }
+
+        .btn-primary {
+            background-color: #0d6efd;
+            border-color: #0d6efd;
+            color: #fff;
+        }
+
+        .btn-primary:hover {
+            background-color: #0b5ed7;
+            border-color: #0a58ca;
+            color: #fff;
+        }
+
+        .btn-outline-secondary {
+            color: #e0e0e0;
+            border-color: #666;
+        }
+
+        .btn-outline-secondary:hover {
+            background-color: #444;
+            color: #fff;
+        }
+
+        .btn-outline-info {
+            color: #0dcaf0;
+            border-color: #0dcaf0;
+        }
+
+        .btn-outline-info:hover {
+            background-color: #0dcaf0;
+            color: #1e1e1e;
+        }
+    </style>
+</head>
+
+<body>
+    <div class="container-fluid">
+        <!-- System Description -->
+        <div class="row mb-3">
+            <div class="col-6 text-center">
+                <h2>Image quality (IQ) 편차 완화 학습 시스템</h4>
+            </div>
+            <div class="col-6 text-end">
+                <button id="btnResetAll" class="btn btn-outline-danger">전체 초기화</button>
+            </div>
+            <div class="col-12 text-center">
+                <h5 style="color: #a0a0a0;">좌측부터 숫자 순서대로 진행하세요</h5>
+            </div>
+        </div>
+        <!-- Top Row: Steps with progress bars -->
+        <div class="row top-row">
+            <!-- Step 1: Original Load -->
+            <div class="col-md-3">
+                <div class="step-container">
+                    <div class="step-title">1. 원본 로드</div>
+                    <div class="progress">
+                        <div id="progressOriginal" class="progress-bar" role="progressbar" style="width: 0%;"
+                            aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
+                    </div>
+                    <div class="mb-2">
+                        <div class="d-flex">
+                            <button id="btnBaseLinePath" class="btn btn-sm btn-primary flex-grow-1">기준 라인 폴더</button>
+                            <button id="btnBaseLineHelp" class="btn btn-sm btn-outline-info btn-help">?</button>
+                        </div>
+                    </div>
+                    <div class="mb-2">
+                        <div class="d-flex">
+                            <button id="btnOtherLinePath" class="btn btn-sm btn-primary flex-grow-1">다른 라인 폴더</button>
+                            <button id="btnOtherLineHelp" class="btn btn-sm btn-outline-info btn-help">?</button>
+                        </div>
+                    </div>
+                    <div class="d-grid gap-2">
+                        <button id="btnGenerateAnomaly" class="btn btn-sm btn-warning">A,B 의 anomaly map 생성</button>
+                    </div>
+                </div>
+            </div>
+
+            <!-- Step 2: Sort Image Generation -->
+            <div class="col-md-3">
+                <div class="step-container">
+                    <div class="step-title">2. 정렬 이미지 생성</div>
+                    <div class="progress">
+                        <div id="progressSort" class="progress-bar" role="progressbar" style="width: 0%;"
+                            aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
+                    </div>
+                    <div class="d-grid gap-2">
+                        <button id="btnSort" class="btn btn-warning" disabled>정렬 실행</button>
+                    </div>
+                </div>
+            </div>
+
+            <!-- Step 3: Optimal Augmentation Training -->
+            <div class="col-md-3">
+                <div class="step-container">
+                    <div class="step-title">3. 최적 증강 학습</div>
+                    <div class="progress-info text-center mb-2"
+                        style="font-size: 0.85rem; display: flex; align-items: center; justify-content: center;">
+                        <span id="trialCounterText">Trial: 0</span>
+                        <span style="margin-left: 8px; margin-right: 4px;">Study ID:</span>
+                        <span id="studyIdValue"></span>
+                        <button id="btnStudyIdHelp" class="btn btn-sm btn-outline-info btn-help"
+                            style="margin-left: 4px; padding: 0px 4px;">?</button>
+                    </div>
+                    <div class="d-grid gap-2 mb-2">
+                        <div class="row">
+                            <div class="col-6">
+                                <button id="btnResetAugment" class="btn btn-outline-danger mb-2 w-100">초기화</button>
+                            </div>
+                            <div class="col-6">
+                                <button id="btnStopAugment" class="btn btn-outline-warning mb-2 w-100">중단</button>
+                            </div>
+                        </div>
+                        <button id="btnAugment" class="btn btn-warning" disabled>최적 증강 실행</button>
+                        <button id="btnCheckBestParams" class="btn btn-outline-info">현재 최적 파라미터 확인</button>
+                    </div>
+                </div>
+            </div>
+
+            <!-- Step 4: Final Model Deployment -->
+            <div class="col-md-3">
+                <div class="step-container">
+                    <div class="step-title">4. 최종모델 배포</div>
+                    <div class="progress">
+                        <div id="progressDeploy" class="progress-bar" role="progressbar" style="width: 0%;"
+                            aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
+                    </div>
+                    <div class="d-grid gap-2">
+                        <button id="btnGenerateAlignedAnomaly" class="btn btn-sm btn-warning mb-2">현재 최적 파라미터로 C,D 의
+                            anomaly map 생성</button>
+                        <button id="btnDeploy" class="btn btn-warning" disabled>최종 모델 배포</button>
+                    </div>
+                </div>
+            </div>
+        </div>
+
+        <!-- Bottom Row: Image Display -->
+        <div class="row bottom-row">
+            <!-- Column 1: Base Line Images -->
+            <div class="col-md-3 col-lg-3 col-xl-1-5 image-column">
+                <div id="baseLinePath" class="folder-path">
+                    [A] 기준 라인 폴더
+                    <button class="btn btn-sm btn-outline-secondary path-check-btn">경로</button>
+                </div>
+                <div id="baseLineImages" class="image-container">
+                    <!-- Images will be loaded here -->
+                </div>
+            </div>
+
+            <!-- Column 2: Base Line Anomaly Maps -->
+            <div class="col-md-3 col-lg-3 col-xl-1-5 image-column">
+                <div id="baseLineAnomalyPath" class="folder-path">
+                    A 의 Anomaly Maps
+                    <button class="btn btn-sm btn-outline-secondary path-check-btn">경로</button>
+                </div>
+                <div id="baseLineAnomalyImages" class="image-container">
+                    <!-- Images will be loaded here -->
+                </div>
+            </div>
+
+            <!-- Column 3: Other Line Images -->
+            <div class="col-md-3 col-lg-3 col-xl-1-5 image-column">
+                <div id="otherLinePath" class="folder-path">
+                    [B] 다른 라인 폴더
+                    <button class="btn btn-sm btn-outline-secondary path-check-btn">경로</button>
+                </div>
+                <div id="otherLineImages" class="image-container">
+                    <!-- Images will be loaded here -->
+                </div>
+            </div>
+
+            <!-- Column 4: Other Line Anomaly Maps -->
+            <div class="col-md-3 col-lg-3 col-xl-1-5 image-column">
+                <div id="otherLineAnomalyPath" class="folder-path">
+                    B 의 Anomaly Maps
+                    <button class="btn btn-sm btn-outline-secondary path-check-btn">경로</button>
+                </div>
+                <div id="otherLineAnomalyImages" class="image-container">
+                    <!-- Images will be loaded here -->
+                </div>
+            </div>
+
+            <!-- Column 5: Aligned Base Line Images -->
+            <div class="col-md-3 col-lg-3 col-xl-1-5 image-column">
+                <div id="alignedBaseLinePath" class="folder-path">
+                    [C] 정렬된 A
+                    <button class="btn btn-sm btn-outline-secondary path-check-btn">경로</button>
+                </div>
+                <div id="alignedBaseLineImages" class="image-container">
+                    <!-- Images will be loaded here -->
+                </div>
+            </div>
+
+            <!-- Column 6: Aligned Base Line Anomaly Maps -->
+            <div class="col-md-3 col-lg-3 col-xl-1-5 image-column">
+                <div id="alignedBaseLineAnomalyPath" class="folder-path">
+                    C 의 Anomaly Maps
+                    <button class="btn btn-sm btn-outline-secondary path-check-btn">경로</button>
+                </div>
+                <div id="alignedBaseLineAnomalyImages" class="image-container">
+                    <!-- Images will be loaded here -->
+                </div>
+            </div>
+
+            <!-- Column 7: Aligned Other Line Images -->
+            <div class="col-md-3 col-lg-3 col-xl-1-5 image-column">
+                <div id="alignedOtherLinePath" class="folder-path">
+                    [D] 정렬된 B
+                    <button class="btn btn-sm btn-outline-secondary path-check-btn">경로</button>
+                </div>
+                <div id="alignedOtherLineImages" class="image-container">
+                    <!-- Images will be loaded here -->
+                </div>
+            </div>
+
+            <!-- Column 8: Aligned Other Line Anomaly Maps -->
+            <div class="col-md-3 col-lg-3 col-xl-1-5 image-column">
+                <div id="alignedOtherLineAnomalyPath" class="folder-path">
+                    D 의 Anomaly Maps
+                    <button class="btn btn-sm btn-outline-secondary path-check-btn">경로</button>
+                </div>
+                <div id="alignedOtherLineAnomalyImages" class="image-container">
+                    <!-- Images will be loaded here -->
+                </div>
+            </div>
+        </div>
+    </div>
+
+    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
+    <script>
+        // Variables to store paths
+        let baseLinePath = null;
+        let otherLinePath = null;
+        let alignedBaseLinePath = null;
+        let alignedOtherLinePath = null;
+        let baseLineAnomalyPath = null;
+        let otherLineAnomalyPath = null;
+        let alignedBaseLineAnomalyPath = null;
+        let alignedOtherLineAnomalyPath = null;
+        let isFirstTimePathsSelected = true;
+        let currentStudyId = null;
+        let augmentationRunning = false;
+        let augmentationStartTime = null;
+        let currentTrial = 0;
+        let totalTrials = 300; // Default total trials
+        let bestParams = null; // Store best parameters
+
+        // Load state from localStorage if available (for tab persistence)
+        function loadSavedState() {
+            try {
+                const savedState = localStorage.getItem('iqgenState');
+                if (savedState) {
+                    const state = JSON.parse(savedState);
+                    baseLinePath = state.baseLinePath;
+                    otherLinePath = state.otherLinePath;
+                    alignedBaseLinePath = state.alignedBaseLinePath;
+                    alignedOtherLinePath = state.alignedOtherLinePath;
+                    baseLineAnomalyPath = state.baseLineAnomalyPath;
+                    otherLineAnomalyPath = state.otherLineAnomalyPath;
+                    alignedBaseLineAnomalyPath = state.alignedBaseLineAnomalyPath;
+                    alignedOtherLineAnomalyPath = state.alignedOtherLineAnomalyPath;
+                    isFirstTimePathsSelected = state.isFirstTimePathsSelected;
+                    currentStudyId = state.currentStudyId;
+                    augmentationRunning = state.augmentationRunning;
+                    augmentationStartTime = state.augmentationStartTime;
+                    currentTrial = state.currentTrial || 0;
+                    totalTrials = state.totalTrials || 300;
+                    bestParams = state.bestParams || null;
+
+                    // Update UI based on loaded state
+                    if (baseLinePath) {
+                        progressOriginal.style.width = '50%';
+                        progressOriginal.setAttribute('aria-valuenow', '50');
+                        loadImages(baseLinePath, baseLineImagesContainer);
+                    }
+
+                    if (otherLinePath) {
+                        progressOriginal.style.width = '100%';
+                        progressOriginal.setAttribute('aria-valuenow', '100');
+                        loadImages(otherLinePath, otherLineImagesContainer);
+                    }
+
+                    if (baseLineAnomalyPath) {
+                        loadImages(baseLineAnomalyPath, baseLineAnomalyImagesContainer);
+                    }
+
+                    if (otherLineAnomalyPath) {
+                        loadImages(otherLineAnomalyPath, otherLineAnomalyImagesContainer);
+                    }
+
+                    if (alignedBaseLinePath && alignedOtherLinePath) {
+                        progressSort.style.width = '100%';
+                        progressSort.setAttribute('aria-valuenow', '100');
+                        loadImages(alignedBaseLinePath, alignedBaseLineImagesContainer);
+                        loadImages(alignedOtherLinePath, alignedOtherLineImagesContainer);
+                        btnAugment.disabled = !augmentationRunning;
+                    }
+
+                    if (alignedBaseLineAnomalyPath) {
+                        loadImages(alignedBaseLineAnomalyPath, alignedBaseLineAnomalyImagesContainer);
+                    }
+
+                    if (alignedOtherLineAnomalyPath) {
+                        loadImages(alignedOtherLineAnomalyPath, alignedOtherLineAnomalyImagesContainer);
+                    }
+
+                    if (currentStudyId) {
+                        document.getElementById('studyIdValue').textContent = currentStudyId;
+                    }
+
+                    if (augmentationRunning) {
+                        btnAugment.disabled = true;
+
+                        // Update trial counter
+                        document.getElementById('trialCounterText').textContent = `Trial: ${currentTrial}`;
+
+                        // Re-register for progress updates from any running process
+                        window.electronAPI.onAugmentationProgress &&
+                            window.electronAPI.onAugmentationProgress(updateAugmentationProgress);
+                    }
+
+                    checkBothPathsSelected();
+
+                    // Update the C,D anomaly maps generation button state based on bestParams
+                    if (btnGenerateAlignedAnomaly) {
+                        btnGenerateAlignedAnomaly.disabled = !bestParams || !alignedBaseLinePath || !alignedOtherLinePath;
+                    }
+                }
+            } catch (error) {
+                console.error('Error loading saved state:', error);
+            }
+        }
+
+        // Save current state to localStorage
+        function saveCurrentState() {
+            try {
+                const state = {
+                    baseLinePath,
+                    otherLinePath,
+                    alignedBaseLinePath,
+                    alignedOtherLinePath,
+                    baseLineAnomalyPath,
+                    otherLineAnomalyPath,
+                    alignedBaseLineAnomalyPath,
+                    alignedOtherLineAnomalyPath,
+                    isFirstTimePathsSelected,
+                    currentStudyId,
+                    augmentationRunning,
+                    augmentationStartTime,
+                    currentTrial,
+                    totalTrials,
+                    bestParams
+                };
+
+                localStorage.setItem('iqgenState', JSON.stringify(state));
+            } catch (error) {
+                console.error('Error saving state:', error);
+            }
+        }
+
+        // Update function to handle study progress updates
+        function updateAugmentationProgress(data) {
+            console.log('Augmentation progress update:', data);
+
+            if (data.current_trial !== undefined) {
+                currentTrial = parseInt(data.current_trial);
+                totalTrials = data.total_trials ? parseInt(data.total_trials) : totalTrials;
+
+                // Update trial counter
+                document.getElementById('trialCounterText').textContent = `Trial: ${currentTrial}`;
+            }
+
+            // Save best parameters
+            if (data.best_params) {
+                bestParams = data.best_params;
+                console.log('Updated best parameters:', bestParams);
+
+                // Enable C,D anomaly map generation if aligned paths exist
+                if (alignedBaseLinePath && alignedOtherLinePath) {
+                    btnGenerateAlignedAnomaly.disabled = false;
+                }
+            }
+
+            if (data.study_id && (!currentStudyId || data.study_id !== currentStudyId)) {
+                currentStudyId = data.study_id;
+                document.getElementById('studyIdValue').textContent = currentStudyId;
+            }
+
+            if (data.status === 'complete') {
+                augmentationRunning = false;
+                btnAugment.disabled = false;
+                btnDeploy.disabled = false;
+                document.getElementById('trialCounterText').textContent = `Trial: ${currentTrial} (완료)`;
+            }
+
+            saveCurrentState();
+        }
+
+        // DOM Elements
+        const progressOriginal = document.getElementById('progressOriginal');
+        const progressSort = document.getElementById('progressSort');
+        const progressDeploy = document.getElementById('progressDeploy');
+
+        const btnBaseLinePath = document.getElementById('btnBaseLinePath');
+        const btnOtherLinePath = document.getElementById('btnOtherLinePath');
+        const btnSort = document.getElementById('btnSort');
+        const btnAugment = document.getElementById('btnAugment');
+        const btnResetAugment = document.getElementById('btnResetAugment');
+        const btnStopAugment = document.getElementById('btnStopAugment');
+        const btnCheckBestParams = document.getElementById('btnCheckBestParams');
+        const btnDeploy = document.getElementById('btnDeploy');
+        const btnGenerateAnomaly = document.getElementById('btnGenerateAnomaly');
+        const btnGenerateAlignedAnomaly = document.getElementById('btnGenerateAlignedAnomaly');
+        const btnResetAll = document.getElementById('btnResetAll');
+
+        const btnBaseLineHelp = document.getElementById('btnBaseLineHelp');
+        const btnOtherLineHelp = document.getElementById('btnOtherLineHelp');
+
+        const baseLinePathElem = document.getElementById('baseLinePath');
+        const otherLinePathElem = document.getElementById('otherLinePath');
+        const alignedBaseLinePathElem = document.getElementById('alignedBaseLinePath');
+        const alignedOtherLinePathElem = document.getElementById('alignedOtherLinePath');
+        const baseLineAnomalyPathElem = document.getElementById('baseLineAnomalyPath');
+        const otherLineAnomalyPathElem = document.getElementById('otherLineAnomalyPath');
+        const alignedBaseLineAnomalyPathElem = document.getElementById('alignedBaseLineAnomalyPath');
+        const alignedOtherLineAnomalyPathElem = document.getElementById('alignedOtherLineAnomalyPath');
+
+        // Add event listeners for path check buttons
+        document.querySelectorAll('.path-check-btn').forEach(btn => {
+            btn.addEventListener('click', function () {
+                const parentId = this.parentElement.id;
+                let pathToShow = '';
+
+                switch (parentId) {
+                    case 'baseLinePath':
+                        pathToShow = baseLinePath || '선택되지 않음';
+                        break;
+                    case 'otherLinePath':
+                        pathToShow = otherLinePath || '선택되지 않음';
+                        break;
+                    case 'alignedBaseLinePath':
+                        pathToShow = alignedBaseLinePath || '선택되지 않음';
+                        break;
+                    case 'alignedOtherLinePath':
+                        pathToShow = alignedOtherLinePath || '선택되지 않음';
+                        break;
+                    case 'baseLineAnomalyPath':
+                        pathToShow = baseLineAnomalyPath || '선택되지 않음';
+                        break;
+                    case 'otherLineAnomalyPath':
+                        pathToShow = otherLineAnomalyPath || '선택되지 않음';
+                        break;
+                    case 'alignedBaseLineAnomalyPath':
+                        pathToShow = alignedBaseLineAnomalyPath || '선택되지 않음';
+                        break;
+                    case 'alignedOtherLineAnomalyPath':
+                        pathToShow = alignedOtherLineAnomalyPath || '선택되지 않음';
+                        break;
+                }
+
+                showHelpMessage(`폴더 경로: ${pathToShow}`);
+            });
+        });
+
+        const baseLineImagesContainer = document.getElementById('baseLineImages');
+        const otherLineImagesContainer = document.getElementById('otherLineImages');
+        const alignedBaseLineImagesContainer = document.getElementById('alignedBaseLineImages');
+        const alignedOtherLineImagesContainer = document.getElementById('alignedOtherLineImages');
+        const baseLineAnomalyImagesContainer = document.getElementById('baseLineAnomalyImages');
+        const otherLineAnomalyImagesContainer = document.getElementById('otherLineAnomalyImages');
+        const alignedBaseLineAnomalyImagesContainer = document.getElementById('alignedBaseLineAnomalyImages');
+        const alignedOtherLineAnomalyImagesContainer = document.getElementById('alignedOtherLineAnomalyImages');
+
+        // 시작 시 preload 스크립트가 로드되었는지 확인
+        console.log('IQGen HTML loaded. Checking if electronAPI is available:', !!window.electronAPI);
+
+        // 초기 버튼 상태 설정
+        btnGenerateAnomaly.disabled = true;
+        btnGenerateAlignedAnomaly.disabled = true;
+
+        // Anomaly map 생성 버튼 클릭 이벤트
+        btnGenerateAnomaly.addEventListener('click', async () => {
+            try {
+                if (baseLinePath && otherLinePath) {
+                    await runDistOnnx(baseLinePath, otherLinePath, false);
+                } else {
+                    showHelpMessage('기준 라인과 다른 라인 폴더를 모두 선택해주세요.');
+                }
+            } catch (error) {
+                console.error('Error generating anomaly maps:', error);
+                showHelpMessage('Anomaly map 생성 중 오류가 발생했습니다: ' + error.message);
+            }
+        });
+
+        // C,D 의 Anomaly map 생성 버튼 클릭 이벤트
+        btnGenerateAlignedAnomaly.addEventListener('click', async () => {
+            try {
+                if (!alignedBaseLinePath || !alignedOtherLinePath) {
+                    showHelpMessage('정렬된 이미지 폴더가 필요합니다. 먼저 이미지 정렬을 실행해주세요.');
+                    return;
+                }
+
+                // 최적 파라미터 확인
+                if (!bestParams) {
+                    showHelpMessage('최적 증강 파라미터가 필요합니다. 먼저 최적 증강 학습을 실행해주세요.');
+                    return;
+                }
+
+                await runDistOnnx(alignedBaseLinePath, alignedOtherLinePath, true, bestParams);
+                // C,D anomaly maps가 생성되면 배포 버튼 활성화
+                btnDeploy.disabled = false;
+            } catch (error) {
+                console.error('Error generating aligned anomaly maps:', error);
+                showHelpMessage('정렬된 이미지의 Anomaly map 생성 중 오류가 발생했습니다: ' + error.message);
+            }
+        });
+
+        // 전체 초기화 버튼 클릭 이벤트
+        btnResetAll.addEventListener('click', async () => {
+            try {
+                // 사용자 확인 메시지
+                const result = await window.electronAPI.showMessageBox({
+                    type: 'question',
+                    title: '전체 초기화 확인',
+                    message: '모든 데이터와 설정을 초기화하시겠습니까?\n이 작업은 되돌릴 수 없습니다.',
+                    buttons: ['취소', '초기화'],
+                    defaultId: 1,
+                    cancelId: 0
+                });
+
+                // 사용자가 '초기화' 버튼을 선택한 경우
+                if (result.response === 1) {
+                    // 진행 상태 바 초기화
+                    progressOriginal.style.width = '0%';
+                    progressOriginal.setAttribute('aria-valuenow', '0');
+                    progressSort.style.width = '0%';
+                    progressSort.setAttribute('aria-valuenow', '0');
+                    progressDeploy.style.width = '0%';
+                    progressDeploy.setAttribute('aria-valuenow', '0');
+
+                    // 경로 변수 초기화
+                    baseLinePath = null;
+                    otherLinePath = null;
+                    alignedBaseLinePath = null;
+                    alignedOtherLinePath = null;
+                    baseLineAnomalyPath = null;
+                    otherLineAnomalyPath = null;
+                    alignedBaseLineAnomalyPath = null;
+                    alignedOtherLineAnomalyPath = null;
+
+                    // 버튼 상태 초기화
+                    btnSort.disabled = true;
+                    btnAugment.disabled = true;
+                    btnDeploy.disabled = true;
+                    btnGenerateAnomaly.disabled = true;
+                    btnGenerateAlignedAnomaly.disabled = true;
+
+                    // HPO 상태 초기화
+                    currentStudyId = null;
+                    document.getElementById('studyIdValue').textContent = '';
+                    document.getElementById('trialCounterText').textContent = 'Trial: 0';
+                    currentTrial = 0;
+                    totalTrials = 300;
+                    bestParams = null;
+
+                    // 첫 경로 선택 플래그 재설정
+                    isFirstTimePathsSelected = true;
+
+                    // 이미지 컨테이너 비우기
+                    baseLineImagesContainer.innerHTML = '';
+                    otherLineImagesContainer.innerHTML = '';
+                    baseLineAnomalyImagesContainer.innerHTML = '';
+                    otherLineAnomalyImagesContainer.innerHTML = '';
+                    alignedBaseLineImagesContainer.innerHTML = '';
+                    alignedOtherLineImagesContainer.innerHTML = '';
+                    alignedBaseLineAnomalyImagesContainer.innerHTML = '';
+                    alignedOtherLineAnomalyImagesContainer.innerHTML = '';
+
+                    // localStorage 상태도 비움
+                    localStorage.removeItem('iqgenState');
+
+                    showHelpMessage('전체 초기화가 완료되었습니다.');
+                }
+            } catch (error) {
+                console.error('Error resetting application:', error);
+                showHelpMessage('초기화 중 오류가 발생했습니다: ' + error.message);
+            }
+        });
+
+        // 탭 활성화 이벤트 리스너 등록 (index.html에서 보내는 이벤트)
+        if (window.electronAPI && window.electronAPI.onTabEvent) {
+            window.electronAPI.onTabEvent((event) => {
+                console.log('Tab event received:', event);
+
+                if (event === 'focus' || event === 'activated') {
+                    // 탭이 활성화될 때 상태를 다시 확인하고 이벤트 리스너 재등록
+                    refreshHpoStatus();
+                }
+            });
+        }
+
+        // HPO 상태 갱신 및 이벤트 리스너 재등록
+        async function refreshHpoStatus() {
+            try {
+                if (window.electronAPI && window.electronAPI.checkHpoStatus) {
+                    const status = await window.electronAPI.checkHpoStatus();
+                    console.log('HPO status refresh on tab activation:', status);
+
+                    // HPO 실행 중이면 상태 업데이트 및 리스너 등록
+                    if (status.isRunning) {
+                        augmentationRunning = true;
+                        btnAugment.disabled = true;
+
+                        // 최신 상태가 있으면 UI 업데이트
+                        if (currentTrial > 0) {
+                            document.getElementById('trialCounterText').textContent = `Trial: ${currentTrial}`;
+                        }
+
+                        // 진행 상황 리스너 재등록
+                        if (window.electronAPI.onAugmentationProgress) {
+                            console.log('Re-registering for augmentation progress updates');
+                            window.electronAPI.onAugmentationProgress(updateAugmentationProgress);
+                        }
+                    }
+                }
+            } catch (error) {
+                console.error('Error refreshing HPO status:', error);
+            }
+        }
+
+        // Load saved state from localStorage (for tab persistence)
+        document.addEventListener('DOMContentLoaded', async () => {
+            loadSavedState();
+
+            // 페이지 로드 시 HPO 프로세스 상태 확인
+            try {
+                if (window.electronAPI && window.electronAPI.checkHpoStatus) {
+                    const status = await window.electronAPI.checkHpoStatus();
+                    console.log('HPO status check on page load:', status);
+
+                    // 실행 중인 경우 버튼 비활성화 및 상태 업데이트
+                    if (status.isRunning) {
+                        augmentationRunning = true;
+                        btnAugment.disabled = true;
+
+                        // 진행 중인 프로세스의 업데이트를 받기 위해 이벤트 리스너 등록
+                        if (window.electronAPI.onAugmentationProgress) {
+                            window.electronAPI.onAugmentationProgress(updateAugmentationProgress);
+                        }
+
+                        // 상태 저장
+                        saveCurrentState();
+                    }
+                }
+            } catch (error) {
+                console.error('Error checking HPO status:', error);
+            }
+
+            // C,D anomaly maps 생성 버튼 초기 상태 설정
+            btnGenerateAlignedAnomaly.disabled = !bestParams;
+        });
+
+        // Help message handlers
+        btnBaseLineHelp.addEventListener('click', () => {
+            showHelpMessage('학습 기준이 될 라인에서 촬영한 이미지들이 있는 경로를 선택합니다.');
+        });
+
+        btnOtherLineHelp.addEventListener('click', () => {
+            showHelpMessage('일반화 할 다른 라인(IQ 편차가 있는 라인)에서 촬영한 이미지들이 있는 경로를 선택합니다.');
+        });
+
+        document.getElementById('btnStudyIdHelp').addEventListener('click', () => {
+            showHelpMessage('학습 진행 상황 확인 방법:\n\n1. 좌측의 Dashboard 탭을 클릭하면 학습 진행 상황을 확인할 수 있습니다.\n\n2. 현재 진행 중인 학습을 찾으려면:\n   - 이 화면의 Study ID를 복사하여 Dashboard에서 검색하거나\n   - Dashboard에서 최신순 정렬 시 맨 위에 표시되는 항목을 확인하세요.\n\n3. 학습 완료 시점:\n   - Dashboard에서 IQ편차가 더 이상 줄어들지 않을 때 학습을 중단해도 됩니다(보통 trial 100회 정도 필요합니다).\n   - 중단 버튼을 누른 후, 찾아낸 최적 파라미터로 최종 모델 배포를 진행하세요.\n\n4. 결과 해석:\n   - Dashboard의 History 그래프 값이 높을수록 두 라인 간 IQ편차가 작다는 의미입니다.');
+        });
+
+        // Path selection handlers
+        btnBaseLinePath.addEventListener('click', async () => {
+            try {
+                console.log('기준 라인 폴더 선택 버튼 클릭됨');
+
+                if (!window.electronAPI) {
+                    throw new Error('electronAPI를 찾을 수 없습니다. preload 스크립트가 로드되지 않았습니다.');
+                }
+
+                const result = await window.electronAPI.openDirectoryDialog({ title: '기준 라인 폴더 선택' });
+                console.log('openDirectoryDialog 결과:', result);
+
+                if (!result.canceled && result.filePaths.length > 0) {
+                    const path = result.filePaths[0];
+                    baseLinePath = path;
+
+                    // Update progress bar to 50%
+                    progressOriginal.style.width = '50%';
+                    progressOriginal.setAttribute('aria-valuenow', '50');
+
+                    // Load images
+                    await loadImages(path, baseLineImagesContainer);
+
+                    // Check if both paths are selected
+                    checkBothPathsSelected();
+
+                    // Save the current state
+                    saveCurrentState();
+                }
+            } catch (error) {
+                console.error('Error selecting directory:', error);
+                showHelpMessage('폴더 선택 중 오류가 발생했습니다: ' + error.message);
+            }
+        });
+
+        btnOtherLinePath.addEventListener('click', async () => {
+            try {
+                console.log('다른 라인 폴더 선택 버튼 클릭됨');
+
+                if (!window.electronAPI) {
+                    throw new Error('electronAPI를 찾을 수 없습니다. preload 스크립트가 로드되지 않았습니다.');
+                }
+
+                const result = await window.electronAPI.openDirectoryDialog({ title: '다른 라인 폴더 선택' });
+                console.log('openDirectoryDialog 결과:', result);
+
+                if (!result.canceled && result.filePaths.length > 0) {
+                    const path = result.filePaths[0];
+                    otherLinePath = path;
+
+                    // Update progress bar to 100%
+                    progressOriginal.style.width = '100%';
+                    progressOriginal.setAttribute('aria-valuenow', '100');
+
+                    // Load images
+                    await loadImages(path, otherLineImagesContainer);
+
+                    // Check if both paths are selected
+                    checkBothPathsSelected();
+
+                    // Save the current state
+                    saveCurrentState();
+                }
+            } catch (error) {
+                console.error('Error selecting directory:', error);
+                showHelpMessage('폴더 선택 중 오류가 발생했습니다: ' + error.message);
+            }
+        });
+
+        // Process button handlers
+        btnSort.addEventListener('click', async () => {
+            try {
+                console.log('정렬 실행 버튼 클릭됨');
+
+                // 경로가 선택되었는지 확인
+                if (!baseLinePath || !otherLinePath) {
+                    showHelpMessage('기준 라인과 다른 라인 폴더를 모두 선택해주세요.');
+                    return;
+                }
+
+                // 버튼 비활성화 및 진행 상태 초기화
+                btnSort.disabled = true;
+                progressSort.style.width = '0%';
+                progressSort.setAttribute('aria-valuenow', '0');
+
+                // 정렬된 경로 설정
+                alignedBaseLinePath = baseLinePath + '_aligned';
+                alignedOtherLinePath = otherLinePath + '_aligned';
+
+                // 진행 상황 리스너 설정
+                window.electronAPI.onAlignmentProgress((progress) => {
+                    console.log(`정렬 진행 상황: ${progress}%`);
+                    progressSort.style.width = `${progress}%`;
+                    progressSort.setAttribute('aria-valuenow', progress);
+                });
+
+                // 완료 리스너 설정
+                window.electronAPI.onAlignmentComplete((result) => {
+                    console.log('정렬 프로세스 완료:', result);
+
+                    if (result.success) {
+                        // 정렬 완료 - 진행 바 최대치로 설정
+                        progressSort.style.width = '100%';
+                        progressSort.setAttribute('aria-valuenow', '100');
+
+                        // 정렬된 이미지 로드
+                        loadImages(alignedBaseLinePath, alignedBaseLineImagesContainer);
+                        loadImages(alignedOtherLinePath, alignedOtherLineImagesContainer);
+
+                        // 다음 버튼 활성화
+                        btnAugment.disabled = false;
+                        btnGenerateAlignedAnomaly.disabled = false;
+
+                        showHelpMessage('이미지 정렬이 완료되었습니다.');
+
+                        // Save the current state
+                        saveCurrentState();
+                    } else {
+                        // 정렬 실패
+                        progressSort.style.width = '0%';
+                        progressSort.setAttribute('aria-valuenow', '0');
+
+                        btnSort.disabled = false;
+                        showHelpMessage(`이미지 정렬 중 오류가 발생했습니다: ${result.error || '알 수 없는 오류'}`);
+                    }
+                });
+
+                // 이미지 정렬 시작
+                window.electronAPI.alignImages(baseLinePath, otherLinePath);
+                showHelpMessage('이미지 정렬이 시작되었습니다. 잠시만 기다려 주세요...');
+
+            } catch (error) {
+                console.error('Error during sort:', error);
+                btnSort.disabled = false;
+                showHelpMessage('정렬 과정 중 오류가 발생했습니다: ' + error.message);
+            }
+        });
+
+        // Reset button event handler
+        btnResetAugment.addEventListener('click', async () => {
+            try {
+                console.log('초기화 버튼 클릭됨');
+
+                // 사용자 확인 메시지
+                const result = await window.electronAPI.showMessageBox({
+                    type: 'question',
+                    title: '초기화 확인',
+                    message: '최적 증강 학습을 초기화하시겠습니까?\n실행 중인 프로세스가 종료됩니다.',
+                    buttons: ['취소', '초기화'],
+                    defaultId: 1,
+                    cancelId: 0
+                });
+
+                // 사용자가 '초기화' 버튼을 선택한 경우
+                if (result.response === 1) {
+                    // 프로세스 종료 요청
+                    if (window.electronAPI && window.electronAPI.killHpoProcess) {
+                        await window.electronAPI.killHpoProcess();
+                    }
+
+                    // UI 초기화
+                    document.getElementById('trialCounterText').textContent = 'Trial: 0';
+                    document.getElementById('studyIdValue').textContent = '';
+
+                    // 상태 초기화
+                    augmentationRunning = false;
+                    augmentationStartTime = null;
+                    currentTrial = 0;
+                    totalTrials = 300;
+                    bestParams = null;
+                    currentStudyId = null;
+
+                    // 버튼 상태 업데이트
+                    btnAugment.disabled = false;
+                    btnDeploy.disabled = true;
+
+                    // 상태 저장
+                    saveCurrentState();
+
+                    showHelpMessage('최적 증강 학습이 초기화되었습니다.');
+                }
+            } catch (error) {
+                console.error('Error during reset:', error);
+                showHelpMessage('초기화 중 오류가 발생했습니다: ' + error.message);
+            }
+        });
+
+        // Stop button event handler
+        btnStopAugment.addEventListener('click', async () => {
+            try {
+                console.log('중단 버튼 클릭됨');
+
+                // 실행 중인지 확인
+                if (!augmentationRunning) {
+                    showHelpMessage('실행 중인 최적 증강 학습이 없습니다.');
+                    return;
+                }
+
+                // 사용자 확인 메시지
+                const result = await window.electronAPI.showMessageBox({
+                    type: 'question',
+                    title: '중단 확인',
+                    message: '최적 증강 학습을 중단하시겠습니까?\n현재까지의 최적 파라미터가 유지됩니다.',
+                    buttons: ['취소', '중단'],
+                    defaultId: 1,
+                    cancelId: 0
+                });
+
+                // 사용자가 '중단' 버튼을 선택한 경우
+                if (result.response === 1) {
+                    // 프로세스 종료 요청
+                    if (window.electronAPI && window.electronAPI.killHpoProcess) {
+                        await window.electronAPI.killHpoProcess();
+                    }
+
+                    // 상태 업데이트
+                    augmentationRunning = false;
+
+                    // 버튼 상태 업데이트
+                    btnAugment.disabled = false;
+                    btnDeploy.disabled = false;
+
+                    // UI 업데이트 - 완료 상태로 표시
+                    document.getElementById('trialCounterText').textContent = `Trial: ${currentTrial} (중단됨)`;
+
+                    // 상태 저장
+                    saveCurrentState();
+
+                    showHelpMessage('최적화가 완료되었습니다. 최종 모델 배포를 클릭하세요.');
+                }
+            } catch (error) {
+                console.error('Error during stop:', error);
+                showHelpMessage('중단 중 오류가 발생했습니다: ' + error.message);
+            }
+        });
+
+        // Check best parameters button event handler
+        btnCheckBestParams.addEventListener('click', () => {
+            try {
+                console.log('현재 최적 파라미터 확인 버튼 클릭됨');
+
+                // 베스트 파라미터가 있는지 확인
+                if (!bestParams) {
+                    showHelpMessage('아직 최적 파라미터 정보가 없습니다. 최적 증강 학습을 실행하세요.');
+                    return;
+                }
+
+                // 파라미터 값을 보기 좋게 포맷팅
+                const formattedParams = Object.entries(bestParams)
+                    .map(([key, value]) => `${key}: ${typeof value === 'number' ? value.toFixed(4) : value}`)
+                    .join('\n');
+
+                // 메시지 박스로 표시
+                showHelpMessage(`현재 최적 파라미터:\n${formattedParams}`);
+            } catch (error) {
+                console.error('Error checking best parameters:', error);
+                showHelpMessage('파라미터 확인 중 오류가 발생했습니다: ' + error.message);
+            }
+        });
+
+        btnAugment.addEventListener('click', async () => {
+            try {
+                console.log('최적 증강 실행 버튼 클릭됨');
+
+                // 경로가 선택되었는지 확인
+                if (!alignedBaseLinePath || !alignedOtherLinePath) {
+                    showHelpMessage('정렬된 이미지가 필요합니다. 먼저 이미지 정렬을 실행해주세요.');
+                    return;
+                }
+
+                // 버튼 비활성화 및 진행 상태 초기화
+                btnAugment.disabled = true;
+                document.getElementById('trialCounterText').textContent = 'Trial: 0';
+                document.getElementById('studyIdValue').textContent = '';
+                currentTrial = 0;
+                totalTrials = 300; // 기본값
+                bestParams = null;
+
+                // 시작 시간 기록
+                augmentationStartTime = Date.now();
+
+                // 이전 study_id 정보 초기화
+                currentStudyId = null;
+
+                // 진행 상황 리스너 설정
+                if (window.electronAPI && window.electronAPI.onAugmentationProgress) {
+                    window.electronAPI.onAugmentationProgress(updateAugmentationProgress);
+                } else {
+                    console.error('electronAPI.onAugmentationProgress is not available');
+                    showHelpMessage('이벤트 리스너를 설정할 수 없습니다. 애플리케이션을 재시작해주세요.');
+                    btnAugment.disabled = false;
+                    return;
+                }
+
+                // HPO 스크립트 실행
+                augmentationRunning = true;
+                saveCurrentState();
+
+                // 실제 Python 스크립트 실행
+                if (window.electronAPI && window.electronAPI.runHpoOnnx) {
+                    window.electronAPI.runHpoOnnx(alignedBaseLinePath, alignedOtherLinePath);
+                } else {
+                    console.error('electronAPI.runHpoOnnx is not available');
+                    showHelpMessage('Python 스크립트를 실행할 수 없습니다. 애플리케이션을 재시작해주세요.');
+                    btnAugment.disabled = false;
+                    augmentationRunning = false;
+                    return;
+                }
+
+                showHelpMessage('최적 증강 학습이 시작되었습니다. 이 과정은 시간이 걸릴 수 있습니다.');
+
+            } catch (error) {
+                console.error('Error during augmentation:', error);
+                btnAugment.disabled = false;
+                augmentationRunning = false;
+                showHelpMessage('증강 학습 중 오류가 발생했습니다: ' + error.message);
+            }
+        });
+
+        btnDeploy.addEventListener('click', async () => {
+            try {
+                console.log('최종 모델 배포 버튼 클릭됨');
+
+                if (!window.electronAPI) {
+                    throw new Error('electronAPI를 찾을 수 없습니다. preload 스크립트가 로드되지 않았습니다.');
+                }
+
+                // Check if aligned paths exist
+                if (!alignedBaseLinePath || !alignedOtherLinePath) {
+                    showHelpMessage('정렬된 이미지 폴더가 없습니다. 먼저 정렬 실행을 진행해주세요.');
+                    return;
+                }
+
+                // Check if aligned anomaly maps exist
+                if (!alignedBaseLineAnomalyPath || !alignedOtherLineAnomalyPath) {
+                    showHelpMessage('C,D 의 Anomaly Maps가 필요합니다. 먼저 C,D 의 anomaly map 생성을 진행해주세요.');
+                    return;
+                }
+
+                // Check if best parameters exist
+                if (!bestParams) {
+                    showHelpMessage('최적 증강 파라미터가 필요합니다. 먼저 최적 증강 학습을 실행해주세요.');
+                    return;
+                }
+
+                const result = await window.electronAPI.openDirectoryDialog({ title: '모델 배포 경로 선택' });
+                console.log('openDirectoryDialog 결과:', result);
+
+                if (!result.canceled && result.filePaths.length > 0) {
+                    const deployPath = result.filePaths[0];
+
+                    // Store original button text and disable button during deployment
+                    const originalButtonText = btnDeploy.textContent;
+                    btnDeploy.disabled = true;
+                    btnDeploy.textContent = "배포 중...";
+
+                    try {
+                        // Copy required files to the selected path
+                        const sourceFiles = [
+                            'project/python_scripts/memory_dist/nnscorer_search_index.faiss',
+                            'project/python_scripts/models/model.onnx'
+                        ];
+
+                        // Create a best_params.json file with the current best parameters
+                        const bestParamsJson = JSON.stringify(bestParams, null, 2);
+
+                        // Copy files and save best parameters
+                        const copyResult = await window.electronAPI.deployModel({
+                            sourceFiles: sourceFiles,
+                            destinationPath: deployPath,
+                            bestParams: bestParamsJson
+                        });
+
+                        if (copyResult.success) {
+                            // Update progress to 100% when deployment is complete
+                            progressDeploy.style.width = '100%';
+                            progressDeploy.setAttribute('aria-valuenow', '100');
+
+                            showHelpMessage(`모델이 성공적으로 배포되었습니다: ${deployPath}`);
+                        } else {
+                            throw new Error(copyResult.error || '파일 복사 중 오류가 발생했습니다.');
+                        }
+                    } catch (error) {
+                        console.error('Error copying files:', error);
+                        showHelpMessage(`파일 복사 중 오류가 발생했습니다: ${error.message}`);
+                    } finally {
+                        // Restore button state
+                        btnDeploy.textContent = originalButtonText;
+                        btnDeploy.disabled = false;
+                    }
+                }
+            } catch (error) {
+                console.error('Error during deployment:', error);
+                showHelpMessage('모델 배포 중 오류가 발생했습니다: ' + error.message);
+            }
+        });
+
+        // Helper functions
+        function checkBothPathsSelected() {
+            if (baseLinePath && otherLinePath) {
+                btnSort.disabled = false;
+                btnGenerateAnomaly.disabled = false;
+
+                // Show first-time instructions
+                if (isFirstTimePathsSelected) {
+                    showHelpMessage('이제 정렬 실행이 가능합니다. 상단에 정렬 실행 버튼을 누르세요');
+                    isFirstTimePathsSelected = false;
+                }
+
+                // Check if aligned folders already exist with all images
+                checkAlignedFolders();
+            } else {
+                btnGenerateAnomaly.disabled = true;
+            }
+        }
+
+        async function checkAlignedFolders() {
+            try {
+                const possibleBaseAligned = baseLinePath + '_aligned';
+                const possibleOtherAligned = otherLinePath + '_aligned';
+                const possibleBaseAnomalyMaps = baseLinePath + '_anomaly_maps';
+                const possibleOtherAnomalyMaps = otherLinePath + '_anomaly_maps';
+                const possibleAlignedBaseAnomalyMaps = possibleBaseAligned + '_anomaly_maps';
+                const possibleAlignedOtherAnomalyMaps = possibleOtherAligned + '_anomaly_maps';
+
+                // Check if directories exist
+                const baseAlignedExists = await window.electronAPI.directoryExists(possibleBaseAligned);
+                const otherAlignedExists = await window.electronAPI.directoryExists(possibleOtherAligned);
+                const baseAnomalyMapsExists = await window.electronAPI.directoryExists(possibleBaseAnomalyMaps);
+                const otherAnomalyMapsExists = await window.electronAPI.directoryExists(possibleOtherAnomalyMaps);
+                const alignedBaseAnomalyMapsExists = await window.electronAPI.directoryExists(possibleAlignedBaseAnomalyMaps);
+                const alignedOtherAnomalyMapsExists = await window.electronAPI.directoryExists(possibleAlignedOtherAnomalyMaps);
+
+                // Check for anomaly maps and load if they exist
+                if (baseAnomalyMapsExists) {
+                    baseLineAnomalyPath = possibleBaseAnomalyMaps;
+                    await loadImages(baseLineAnomalyPath, baseLineAnomalyImagesContainer);
+                }
+
+                if (otherAnomalyMapsExists) {
+                    otherLineAnomalyPath = possibleOtherAnomalyMaps;
+                    await loadImages(otherLineAnomalyPath, otherLineAnomalyImagesContainer);
+                }
+
+                if (baseAlignedExists && otherAlignedExists) {
+                    // Get file lists from all directories
+                    const baseFiles = await window.electronAPI.readDirectory(baseLinePath);
+                    const otherFiles = await window.electronAPI.readDirectory(otherLinePath);
+                    const baseAlignedFiles = await window.electronAPI.readDirectory(possibleBaseAligned);
+                    const otherAlignedFiles = await window.electronAPI.readDirectory(possibleOtherAligned);
+
+                    // Filter only image files
+                    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp'];
+                    const isImageFile = file => {
+                        const lowerFile = file.toLowerCase();
+                        return imageExtensions.some(ext => lowerFile.endsWith(ext));
+                    };
+
+                    const baseImages = baseFiles.filter(isImageFile);
+                    const baseAlignedImages = baseAlignedFiles.filter(isImageFile);
+                    const otherImages = otherFiles.filter(isImageFile);
+                    const otherAlignedImages = otherAlignedFiles.filter(isImageFile);
+
+                    // Check if all images from original folders exist in aligned folders
+                    const allBaseImagesAligned = baseImages.every(img => baseAlignedImages.includes(img));
+                    const allOtherImagesAligned = otherImages.every(img => otherAlignedImages.includes(img));
+
+                    if (allBaseImagesAligned && allOtherImagesAligned) {
+                        // Set aligned paths
+                        alignedBaseLinePath = possibleBaseAligned;
+                        alignedOtherLinePath = possibleOtherAligned;
+
+                        // Update UI to show alignment is complete
+                        progressSort.style.width = '100%';
+                        progressSort.setAttribute('aria-valuenow', '100');
+                        btnAugment.disabled = false;
+                        btnSort.disabled = true;
+                        btnGenerateAlignedAnomaly.disabled = false;
+
+                        // Load aligned images
+                        await loadImages(alignedBaseLinePath, alignedBaseLineImagesContainer);
+                        await loadImages(alignedOtherLinePath, alignedOtherLineImagesContainer);
+
+                        // Check for aligned anomaly maps and load if they exist
+                        if (alignedBaseAnomalyMapsExists) {
+                            alignedBaseLineAnomalyPath = possibleAlignedBaseAnomalyMaps;
+                            await loadImages(alignedBaseLineAnomalyPath, alignedBaseLineAnomalyImagesContainer);
+                        }
+
+                        if (alignedOtherAnomalyMapsExists) {
+                            alignedOtherLineAnomalyPath = possibleAlignedOtherAnomalyMaps;
+                            await loadImages(alignedOtherLineAnomalyPath, alignedOtherLineAnomalyImagesContainer);
+
+                            // Enable deploy button if aligned anomaly maps exist
+                            btnDeploy.disabled = false;
+                        }
+
+                        // Show message
+                        showHelpMessage('이미 정렬완료된 데이터입니다.');
+
+                        // Save the current state
+                        saveCurrentState();
+                    }
+                }
+            } catch (error) {
+                console.error('Error checking aligned folders:', error);
+                // Continue without showing errors to the user
+            }
+        }
+
+        async function loadImages(path, container) {
+            // Clear container
+            container.innerHTML = '';
+
+            try {
+                // Get image files from the directory
+                const files = await window.electronAPI.readDirectory(path);
+
+                // Filter only image files by extension
+                const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp'];
+                const imageFiles = files.filter(file => {
+                    const lowerFile = file.toLowerCase();
+                    return imageExtensions.some(ext => lowerFile.endsWith(ext));
+                });
+
+                // Limit to 50 images
+                const limitedImages = imageFiles.slice(0, 50);
+
+                if (limitedImages.length === 0) {
+                    container.innerHTML = '<p>이미지 파일이 없습니다.</p>';
+                    return;
+                }
+
+                // Create image elements
+                limitedImages.forEach(file => {
+                    const img = document.createElement('img');
+                    img.src = `file://${path}/${file}`;
+                    img.alt = file;
+                    img.title = file;
+                    container.appendChild(img);
+                });
+            } catch (error) {
+                console.error('Error loading images:', error);
+                container.innerHTML = '<p>이미지를 불러올 수 없습니다.</p>';
+
+                // 오류 시 샘플 이미지 생성 (테스트용)
+                for (let i = 1; i <= 5; i++) {
+                    const img = document.createElement('img');
+                    img.src = `https://via.placeholder.com/150?text=sample_${i}`;
+                    img.alt = `sample_${i}.jpg`;
+                    img.title = `sample_${i}.jpg`;
+                    container.appendChild(img);
+                }
+            }
+        }
+
+        function showHelpMessage(message) {
+            try {
+                // Use parent window's message box
+                window.electronAPI.showMessageBox({
+                    type: 'info',
+                    title: '안내',
+                    message: message,
+                    buttons: ['확인']
+                });
+            } catch (error) {
+                // Fallback to alert if parent messaging fails
+                alert(message);
+            }
+        }
+
+        async function simulateProcess(processName) {
+            return new Promise(resolve => {
+                // Simulate a process with a timeout
+                console.log(`Starting: ${processName}`);
+                setTimeout(() => {
+                    console.log(`Completed: ${processName}`);
+                    resolve();
+                }, 1500);
+            });
+        }
+
+        // Function to run dist_onnx.py to generate anomaly maps
+        async function runDistOnnx(inputPath1, inputPath2, isFinished = false, params = null) {
+            try {
+                console.log(`Running dist_onnx.py for paths: ${inputPath1}, ${inputPath2}, isFinished: ${isFinished}`);
+
+                if (!window.electronAPI || !window.electronAPI.runPythonScript) {
+                    throw new Error("electronAPI.runPythonScript is not available");
+                }
+
+                // Store original button text
+                const targetButton = isFinished ? btnGenerateAlignedAnomaly : btnGenerateAnomaly;
+                const originalButtonText = targetButton.textContent;
+
+                // Disable both anomaly generation buttons during execution
+                btnGenerateAnomaly.disabled = true;
+                btnGenerateAlignedAnomaly.disabled = true;
+
+                // Set initial progress text
+                targetButton.textContent = "준비 중... (0%)";
+
+                showHelpMessage(`이상 감지 맵을 생성 중입니다. 잠시만 기다려주세요...`);
+
+                // Prepare arguments
+                let scriptArgs = [inputPath1, inputPath2];
+
+                // Add ColorJitter parameters if provided (for aligned images)
+                if (isFinished && params) {
+                    if (params.brightness !== undefined) scriptArgs.push('--brightness', params.brightness.toString());
+                    if (params.contrast !== undefined) scriptArgs.push('--contrast', params.contrast.toString());
+                    if (params.saturation !== undefined) scriptArgs.push('--saturation', params.saturation.toString());
+                    if (params.hue !== undefined) scriptArgs.push('--hue', params.hue.toString());
+                }
+
+                // Add --gap 1.0 parameter when generating aligned anomaly maps
+                if (isFinished) {
+                    scriptArgs.push('--gap', '1.0');
+                }
+
+                // Set up a direct progress listener for this specific execution
+                const progressListener = (event, data) => {
+                    try {
+                        console.log("Progress event received:", data);
+                        const progressData = JSON.parse(data);
+                        if (progressData.progress !== undefined) {
+                            const progressPercent = Math.round(progressData.progress);
+                            const status = progressData.status || "처리 중";
+                            targetButton.textContent = `${status}... (${progressPercent}%)`;
+                        }
+                    } catch (e) {
+                        console.error("Error parsing progress data:", e);
+                    }
+                };
+
+                // Register the progress listener
+                window.electronAPI.ipcRenderer.on('python:progress', progressListener);
+
+                // Run dist_onnx.py script
+                const scriptResult = await window.electronAPI.runPythonScript({
+                    scriptName: 'dist_onnx.py',
+                    args: scriptArgs
+                });
+
+                // Remove the progress listener after completion
+                window.electronAPI.ipcRenderer.removeListener('python:progress', progressListener);
+
+                console.log('dist_onnx.py execution result:', scriptResult);
+
+                // Restore original button text
+                targetButton.textContent = originalButtonText;
+
+                if (scriptResult.success) {
+                    // Set anomaly map paths
+                    const anomalyPath1 = `${inputPath1}_anomaly_maps`;
+                    const anomalyPath2 = `${inputPath2}_anomaly_maps`;
+
+                    if (!isFinished) {
+                        // For original images
+                        baseLineAnomalyPath = anomalyPath1;
+                        otherLineAnomalyPath = anomalyPath2;
+
+                        // Load images into the UI
+                        await loadImages(baseLineAnomalyPath, baseLineAnomalyImagesContainer);
+                        await loadImages(otherLineAnomalyPath, otherLineAnomalyImagesContainer);
+
+                        // Re-enable the original anomaly map generation button
+                        btnGenerateAnomaly.disabled = false;
+
+                        // Only enable aligned button if we have aligned paths and best params
+                        btnGenerateAlignedAnomaly.disabled = !(alignedBaseLinePath && alignedOtherLinePath && bestParams);
+                    } else {
+                        // For aligned images
+                        alignedBaseLineAnomalyPath = anomalyPath1;
+                        alignedOtherLineAnomalyPath = anomalyPath2;
+
+                        // Load images into the UI
+                        await loadImages(alignedBaseLineAnomalyPath, alignedBaseLineAnomalyImagesContainer);
+                        await loadImages(alignedOtherLineAnomalyPath, alignedOtherLineAnomalyImagesContainer);
+
+                        // Update progress
+                        progressDeploy.style.width = '50%';
+                        progressDeploy.setAttribute('aria-valuenow', '50');
+
+                        // Enable deploy button after aligned anomaly maps are generated
+                        btnDeploy.disabled = false;
+
+                        // Re-enable the original anomaly map generation buttons
+                        btnGenerateAnomaly.disabled = false;
+                        btnGenerateAlignedAnomaly.disabled = false;
+                    }
+
+                    // Save the current state
+                    saveCurrentState();
+
+                    showHelpMessage('이상 감지 맵 생성이 완료되었습니다.');
+                } else {
+                    // Re-enable buttons on error
+                    btnGenerateAnomaly.disabled = false;
+                    btnGenerateAlignedAnomaly.disabled = !(alignedBaseLinePath && alignedOtherLinePath && bestParams);
+
+                    showHelpMessage(`이상 감지 맵 생성 중 오류가 발생했습니다: ${scriptResult.error || '알 수 없는 오류'}`);
+                }
+            } catch (error) {
+                console.error('Error running dist_onnx.py:', error);
+
+                // Restore buttons on exception
+                btnGenerateAnomaly.disabled = false;
+                btnGenerateAlignedAnomaly.disabled = !(alignedBaseLinePath && alignedOtherLinePath && bestParams);
+
+                // Restore original button text if possible
+                if (isFinished) {
+                    btnGenerateAlignedAnomaly.textContent = "현재 최적 파라미터로 C,D 의 anomaly map 생성";
+                } else {
+                    btnGenerateAnomaly.textContent = "A,B 의 anomaly map 생성";
+                }
+
+                showHelpMessage(`dist_onnx.py 실행 중 오류가 발생했습니다: ${error.message}`);
+            }
+        }
+    </script>
+</body>
+
+</html>
\ No newline at end of file
diff --git a/project/main.js b/project/main.js
index 3fcefc7..eff60be 100644
--- a/project/main.js
+++ b/project/main.js
@@ -486,8 +486,118 @@ app.on('window-all-closed', () => {
 app.on('before-quit', async () => {
     await kill_pyhpo();
     await kill_dashboard();
+
+    // 정렬 프로세스 종료
+    if (alignmentProcess) {
+        alignmentProcess.kill();
+        alignmentProcess = null;
+        console.log('[INFO] Alignment process terminated');
+    }
 });
 
+/** XFeat 이미지 정렬 실행 */
+let alignmentProcess = null;
+async function runXFeatAligner(baseLinePath, otherLinePath, event) {
+    // 기존 프로세스 종료
+    if (alignmentProcess) {
+        alignmentProcess.kill();
+        alignmentProcess = null;
+    }
+
+    const { base, pyScripts, pythonExe } = getPaths();
+    const alignerScript = path.join(base, 'python_scripts', 'xfeat_aligner.py');
+
+    // 명령어 및 인수 설정
+    let command, args;
+    if (isDev) {
+        // 개발 모드 - Python 스크립트 직접 실행
+        command = 'python';
+    } else {
+        // 배포 모드
+        command = pythonExe;
+    }
+    args = [alignerScript, baseLinePath, otherLinePath, '--root', path.join(base, 'python_scripts')];
+
+    console.log('Starting XFeat alignment:', command, args);
+
+    try {
+        // 환경 변수 설정
+        const env = { ...process.env };
+
+        // 실행 옵션 설정
+        const options = {
+            env,
+            cwd: path.dirname(command),
+            windowsHide: true,
+            stdio: 'pipe'
+        };
+
+        // 프로세스 생성
+        alignmentProcess = spawn(command, args, options);
+
+        // stdout - 진행 상황 처리
+        alignmentProcess.stdout.on('data', (data) => {
+            const output = data.toString().trim();
+            console.log('[xfeat-aligner]', output);
+
+            // JSON 형식의 진행 상황 파싱 및 전달
+            try {
+                const progressData = JSON.parse(output);
+                if (progressData.progress !== undefined) {
+                    // 진행 상황을 렌더러 프로세스로 전송
+                    if (event && event.sender) {
+                        event.sender.send('alignment:progress', progressData.progress);
+                    }
+                }
+            } catch (e) {
+                // JSON이 아닌 일반 출력은 무시
+            }
+        });
+
+        // stderr
+        alignmentProcess.stderr.on('data', (data) => {
+            const errorMsg = data.toString();
+            console.error('[xfeat-aligner-error]', errorMsg);
+        });
+
+        // close
+        alignmentProcess.on('close', (code) => {
+            console.log(`[xfeat-aligner] process exited with code=${code}`);
+            alignmentProcess = null;
+
+            // 완료 또는 오류 상태를 렌더러 프로세스로 전송
+            if (event && event.sender) {
+                event.sender.send('alignment:complete', {
+                    success: code === 0,
+                    error: code !== 0 ? `Process exited with code ${code}` : null
+                });
+            }
+        });
+
+        // error
+        alignmentProcess.on('error', (err) => {
+            console.error('[xfeat-aligner] failed to start:', err);
+            if (event && event.sender) {
+                event.sender.send('alignment:complete', {
+                    success: false,
+                    error: err.message
+                });
+            }
+        });
+
+        return true;
+    } catch (err) {
+        console.error('[ERROR] Failed to start XFeat aligner:', err);
+        if (event && event.sender) {
+            event.sender.send('alignment:complete', {
+                success: false,
+                error: err.message
+            });
+        }
+        return false;
+    }
+}
+
 /** 자식 프로세스 재시작 (기존 run-command를 수정) */
 ipcMain.handle('run-command', async () => {
     try {
@@ -542,7 +652,6 @@ optuna_dashboard.run_server('${dbUrl}', host='127.0.0.1', port=8080)
     });
 }
 
-
 /** 기존 프로세스(서버/대시보드) 종료 */
 async function kill_pyhpo() {
     let killPromises = [];
@@ -588,12 +697,14 @@ async function kill_pyhpo() {
     return true;
 }
 
-/** 기존 프로세스(서버/대시보드) 종료 */
+/** HPO 대시보드 종료 */
 async function kill_dashboard() {
     if (dashboardProcess) {
-        dashboardProcess.kill(); dashboardProcess = null;
-        console.log('[INFO] Dashboard process terminated');
+        dashboardProcess.kill();
+        dashboardProcess = null;
+        await new Promise(resolve => setTimeout(resolve, 500));
     }
+    return true;
 }
 
 /** JSON 관련 함수들 */
@@ -643,4 +754,512 @@ ipcMain.handle('load-results', async () => {
         console.error('Parsing results error:', err);
         return [];
     }
+});
+
+// IPC handlers for IQGen features
+ipcMain.handle('dialog:openDirectory', async (event, options) => {
+    const { canceled, filePaths } = await dialog.showOpenDialog({
+        properties: ['openDirectory'],
+        ...options
+    });
+    return { canceled, filePaths };
+});
+
+// XFeat 이미지 정렬 실행 핸들러
+ipcMain.on('image:align', (event, { baseLinePath, otherLinePath }) => {
+    runXFeatAligner(baseLinePath, otherLinePath, event);
+});
+
+// HPO ONNX 실행 핸들러
+ipcMain.on('hpo:run', (event, { baseLinePath, otherLinePath }) => {
+    runHpoOnnx(baseLinePath, otherLinePath, event);
+});
+
+// HPO 상태 확인 핸들러
+ipcMain.handle('hpo:checkStatus', () => {
+    return {
+        isRunning: hpoOnnxProcess !== null
+    };
+});
+
+// HPO 프로세스 강제 종료 핸들러
+ipcMain.handle('hpo:kill', async () => {
+    try {
+        if (hpoOnnxProcess) {
+            console.log('[INFO] Killing HPO process by user request');
+
+            // 프로세스 종료
+            const killPromise = new Promise((resolve) => {
+                hpoOnnxProcess.on('close', () => {
+                    console.log('[INFO] HPO process terminated via kill()');
+                    resolve(true);
+                });
+
+                hpoOnnxProcess.kill();
+            });
+
+            // 최대 3초 타임아웃
+            const timeoutPromise = new Promise(resolve =>
+                setTimeout(() => {
+                    console.log('[INFO] HPO process kill timeout');
+                    resolve(false);
+                }, 3000)
+            );
+
+            // 종료 결과
+            const killResult = await Promise.race([killPromise, timeoutPromise]);
+
+            // 프로세스 참조 해제
+            hpoOnnxProcess = null;
+
+            return { success: true, timeout: !killResult };
+        } else {
+            console.log('[INFO] No HPO process to kill');
+            return { success: true, notRunning: true };
+        }
+    } catch (error) {
+        console.error('[ERROR] Failed to kill HPO process:', error);
+        return { success: false, error: error.message };
+    }
+});
+
+ipcMain.handle('dialog:showMessageBox', async (event, options) => {
+    return await dialog.showMessageBox(options);
+});
+
+ipcMain.handle('fs:readDirectory', async (event, dirPath) => {
+    try {
+        return await fs.promises.readdir(dirPath);
+    } catch (error) {
+        console.error('Error reading directory:', error);
+        throw error;
+    }
+});
+
+// Check if a directory exists
+ipcMain.handle('fs:directoryExists', async (event, dirPath) => {
+    try {
+        const stats = await fs.promises.stat(dirPath);
+        return stats.isDirectory();
+    } catch (error) {
+        return false;
+    }
+});
+
+// 이미지 처리 핸들러
+ipcMain.handle('image:process', async (event, { sourcePath, targetPath }) => {
+    try {
+        // 여기에 이미지 처리 로직 구현
+        // 예: 이미지 복사, 변환 등
+        console.log(`이미지 처리: ${sourcePath} -> ${targetPath}`);
+        return { success: true, message: '이미지 처리 완료' };
+    } catch (error) {
+        console.error('이미지 처리 오류:', error);
+        return { success: false, message: error.message };
+    }
+});
+
+// 모델 배포 핸들러
+ipcMain.handle('model:deploy', async (event, ...args) => {
+    try {
+        console.log('model:deploy 핸들러 호출됨, 인자 개수:', args.length);
+        console.log('인자 타입들:', args.map(arg => typeof arg));
+
+        // 첫 번째 인자를 options로 사용
+        let options = args[0];
+
+        // 디버깅을 위해 전체 options 객체 로깅
+        console.log('모델 배포 요청 받음, 옵션 타입:', typeof options);
+        console.log('옵션 내용:', options);
+
+        // options가 null 또는 undefined인 경우 빈 객체로 초기화
+        if (!options) {
+            options = {};
+            console.error('옵션 객체가 null 또는 undefined입니다.');
+        }
+
+        // 중첩된 구조 처리 (sourcePath 내부에 실제 옵션이 있는 경우)
+        if (options.sourcePath && typeof options.sourcePath === 'object') {
+            console.log('중첩된 옵션 구조 발견, sourcePath 내부 값을 사용합니다.');
+            options = options.sourcePath;
+        }
+
+        // options 객체에서 필요한 값 추출
+        const sourceFiles = options.sourceFiles || [];
+        const destinationPath = options.destinationPath || '';
+        const bestParams = options.bestParams;
+
+        console.log('모델 배포 시작:', {
+            sourceFilesCount: Array.isArray(sourceFiles) ? sourceFiles.length : 'not an array',
+            destinationPath: destinationPath || 'not provided',
+            hasBestParams: !!bestParams
+        });
+
+        // 필수 매개변수 검증
+        if (!destinationPath) {
+            throw new Error('대상 경로가 지정되지 않았습니다.');
+        }
+
+        if (!sourceFiles || !Array.isArray(sourceFiles) || sourceFiles.length === 0) {
+            throw new Error('복사할 소스 파일이 지정되지 않았습니다.');
+        }
+
+        // 대상 디렉토리가 존재하는지 확인
+        if (!fs.existsSync(destinationPath)) {
+            console.log(`디렉토리 생성: ${destinationPath}`);
+            fs.mkdirSync(destinationPath, { recursive: true });
+        }
+
+        // 애플리케이션 기본 경로 가져오기
+        const { base } = getPaths();
+        console.log('애플리케이션 기본 경로:', base);
+
+        // 파일 복사 함수
+        const copyFile = async (sourcePath, destPath) => {
+            return new Promise((resolve, reject) => {
+                // 소스 파일이 존재하는지 확인
+                if (!fs.existsSync(sourcePath)) {
+                    reject(new Error(`소스 파일이 존재하지 않습니다: ${sourcePath}`));
+                    return;
+                }
+
+                // 파일 복사
+                const readStream = fs.createReadStream(sourcePath);
+                const writeStream = fs.createWriteStream(destPath);
+
+                readStream.on('error', (err) => {
+                    reject(new Error(`파일 읽기 오류: ${err.message}`));
+                });
+
+                writeStream.on('error', (err) => {
+                    reject(new Error(`파일 쓰기 오류: ${err.message}`));
+                });
+
+                writeStream.on('finish', () => {
+                    resolve();
+                });
+
+                readStream.pipe(writeStream);
+            });
+        };
+
+        // 1. 소스 파일들 복사
+        for (const sourceFile of sourceFiles) {
+            // 상대 경로를 절대 경로로 변환
+            const absoluteSourcePath = path.join(base, sourceFile);
+            const fileName = path.basename(sourceFile);
+            const destPath = path.join(destinationPath, fileName);
+
+            console.log(`파일 복사: ${absoluteSourcePath} -> ${destPath}`);
+            await copyFile(absoluteSourcePath, destPath);
+        }
+
+        // 2. Best parameters를 JSON 파일로 저장
+        if (bestParams) {
+            const bestParamsPath = path.join(destinationPath, 'best_params.json');
+            fs.writeFileSync(bestParamsPath, bestParams);
+            console.log(`최적 파라미터 저장: ${bestParamsPath}`);
+        }
+
+        return { success: true, message: '모델 배포 완료' };
+    } catch (error) {
+        console.error('모델 배포 오류:', error);
+        return { success: false, error: error.message };
+    }
+});
+
+// 로그 메시지 수신 핸들러
+ipcMain.on('log:message', (event, message) => {
+    console.log(`IQGen 로그: ${message}`);
+});
+
+// Get path to IQGen preload script
+ipcMain.handle('getIQGenPreloadPath', () => {
+    return path.join(__dirname, 'preload-iqgen.js');
+});
+
+/** HPO ONNX 스크립트 실행 함수 */
+let hpoOnnxProcess = null;
+async function runHpoOnnx(baseLinePath, otherLinePath, event) {
+    // 기존 프로세스 종료
+    if (hpoOnnxProcess) {
+        hpoOnnxProcess.kill();
+        hpoOnnxProcess = null;
+        await new Promise(resolve => setTimeout(resolve, 500));
+    }
+
+    const { base } = getPaths();
+    // 개발 모드에서는 테스트 스크립트 사용, 그렇지 않으면 실제 스크립트 사용
+    const scriptPath = isDev
+        ? path.join(base, 'python_scripts', 'hpo_client.py')
+        : path.join(base, 'python_scripts', 'hpo_client.py');
+
+    // 명령어 및 인수 설정
+    let command, args;
+    if (isDev) {
+        // 개발 모드 - Python 스크립트 직접 실행
+        command = 'python';
+    } else {
+        // 배포 모드
+        const { pythonExe } = getPaths();
+        command = pythonExe;
+    }
+    args = [scriptPath, baseLinePath, otherLinePath, '--root', path.join(base, 'python_scripts')];
+
+    console.log('Starting HPO ONNX process:', command, args);
+
+    try {
+        // 환경 변수 설정
+        const env = { ...process.env };
+
+        // 실행 옵션 설정
+        const options = {
+            env,
+            cwd: path.dirname(command),
+            windowsHide: true,
+            stdio: 'pipe'
+        };
+
+        // 프로세스 생성
+        hpoOnnxProcess = spawn(command, args, options);
+
+        // stdout - 진행 상황 처리
+        hpoOnnxProcess.stdout.on('data', (data) => {
+            const output = data.toString().trim();
+            console.log('[hpo-onnx]', output);
+
+            // JSON 형식의 진행 상황 파싱 및 전달
+            try {
+                // 한 줄에 여러 JSON 객체가 있을 수 있으므로 분리하여 처리
+                const lines = output.split('\n');
+
+                for (const line of lines) {
+                    if (!line.trim()) continue;
+
+                    try {
+                        const progressData = JSON.parse(line.trim());
+
+                        // 진행 상황, study_id 등 처리
+                        if (event && event.sender && !event.sender.isDestroyed()) {
+                            console.log('Sending progress data to renderer:', progressData);
+                            event.sender.send('hpo:progress', progressData);
+                        }
+                    } catch (parseError) {
+                        console.log('Non-JSON output:', line);
+                    }
+                }
+            } catch (e) {
+                console.error('Error processing HPO output:', e);
+            }
+        });
+
+        // stderr
+        hpoOnnxProcess.stderr.on('data', (data) => {
+            const errorMsg = data.toString();
+            console.error('[hpo-onnx-error]', errorMsg);
+
+            // stdout에서 처리하지 못한 study_id 정보가 stderr에 있는지 확인
+            try {
+                // study_id를 찾기 위한 정규식
+                const studyIdMatch = errorMsg.match(/Study\s+ID:\s+(\d+)/i);
+                if (studyIdMatch && studyIdMatch[1]) {
+                    const studyId = studyIdMatch[1];
+                    console.log('Found study_id in stderr:', studyId);
+
+                    if (event && event.sender && !event.sender.isDestroyed()) {
+                        event.sender.send('hpo:progress', {
+                            study_id: studyId
+                        });
+                    }
+                }
+            } catch (e) {
+                // 에러 처리 무시
+            }
+        });
+
+        // close
+        hpoOnnxProcess.on('close', (code) => {
+            console.log(`[hpo-onnx] process exited with code=${code}`);
+
+            // 완료 메시지 전송 (100% 진행율)
+            if (event && event.sender && !event.sender.isDestroyed()) {
+                event.sender.send('hpo:progress', {
+                    progress: 100,
+                    status: 'complete',
+                    success: code === 0,
+                    error: code !== 0 ? `Process exited with code ${code}` : null
+                });
+            }
+
+            hpoOnnxProcess = null;
+        });
+
+        // error
+        hpoOnnxProcess.on('error', (err) => {
+            console.error('[hpo-onnx] failed to start:', err);
+            if (event && event.sender && !event.sender.isDestroyed()) {
+                event.sender.send('hpo:progress', {
+                    progress: 0,
+                    status: 'error',
+                    success: false,
+                    error: err.message
+                });
+            }
+        });
+
+        return true;
+    } catch (err) {
+        console.error('[ERROR] Failed to start HPO ONNX:', err);
+        if (event && event.sender && !event.sender.isDestroyed()) {
+            event.sender.send('hpo:progress', {
+                progress: 0,
+                status: 'error',
+                success: false,
+                error: err.message
+            });
+        }
+        return false;
+    }
+}
+
+/** 일반 Python 스크립트 실행 (dist_onnx.py 등) */
+async function runPythonScript(options) {
+    const { scriptName, args = [] } = options;
+    const { base } = getPaths();
+
+    // Python 스크립트 경로 설정
+    const scriptPath = path.join(base, 'python_scripts', scriptName);
+
+    // 명령어 및 인수 설정
+    let command, scriptArgs;
+    if (isDev) {
+        // 개발 모드 - Python 스크립트 직접 실행
+        command = 'python';
+    } else {
+        // 배포 모드
+        const { pythonExe } = getPaths();
+        command = pythonExe;
+    }
+
+    // 스크립트 인수 구성 - args 배열에 --root 인수 추가
+    scriptArgs = [scriptPath, ...args, '--root', path.join(base, 'python_scripts')];
+    console.log(`Running Python script: ${command} ${scriptArgs.join(' ')}`);
+
+    // 환경 변수를 Promise 밖에서 미리 추출
+    const processEnv = Object.assign({}, process.env);
+
+    // 실행 옵션 설정을 Promise 밖에서 미리 준비
+    const spawnOptions = {
+        env: processEnv,
+        cwd: path.dirname(command),
+        windowsHide: true
+    };
+
+    return new Promise((resolve, reject) => {
+        try {
+            // 프로세스 생성 및 실행 - 미리 준비된 환경 변수와 옵션 사용
+            const childProcess = spawn(command, scriptArgs, spawnOptions);
+
+            let stdoutData = '';
+            let stderrData = '';
+
+            // stdout 데이터 수집
+            childProcess.stdout.on('data', (data) => {
+                const output = data.toString();
+                console.log(`[${scriptName}]`, output);
+                stdoutData += output;
+
+                // 진행 상황 데이터 파싱 시도
+                try {
+                    // 각 줄을 분리하여 JSON 형식의 진행 상황 데이터 찾기
+                    const lines = output.trim().split('\n');
+                    for (const line of lines) {
+                        try {
+                            if (!line.trim()) continue;
+
+                            const jsonData = JSON.parse(line.trim());
+                            // progress 필드가 있으면 진행 상황 데이터로 간주
+                            if (jsonData && jsonData.progress !== undefined) {
+                                // 요청한 윈도우에 직접 진행 상황 이벤트 전송
+                                if (options.event && options.event.sender && !options.event.sender.isDestroyed()) {
+                                    options.event.sender.send('python:progress', line.trim());
+                                } else {
+                                    // 모든 창에 진행 상황 이벤트 전송
+                                    const windows = BrowserWindow.getAllWindows();
+                                    for (const win of windows) {
+                                        if (!win.isDestroyed() && win.webContents) {
+                                            console.log(`[${scriptName}] Sending progress: ${jsonData.progress}% to window`);
+                                            try {
+                                                win.webContents.send('python:progress', line.trim());
+                                            } catch (sendError) {
+                                                console.error('Error sending progress event:', sendError);
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        } catch (e) {
+                            // JSON 파싱 오류는 무시 (일반 텍스트 출력일 수 있음)
+                        }
+                    }
+                } catch (e) {
+                    console.error('Error parsing progress data:', e);
+                }
+            });
+
+            // stderr 데이터 수집
+            childProcess.stderr.on('data', (data) => {
+                const errorOutput = data.toString();
+                console.error(`[${scriptName}-error]`, errorOutput);
+                stderrData += errorOutput;
+            });
+
+            // 프로세스 완료 처리
+            childProcess.on('close', (code) => {
+                console.log(`[${scriptName}] process exited with code ${code}`);
+
+                if (code === 0) {
+                    resolve({
+                        success: true,
+                        stdout: stdoutData,
+                        stderr: stderrData
+                    });
+                } else {
+                    resolve({
+                        success: false,
+                        error: `Process exited with code ${code}`,
+                        stdout: stdoutData,
+                        stderr: stderrData
+                    });
+                }
+            });
+
+            // 프로세스 시작 오류 처리
+            childProcess.on('error', (err) => {
+                console.error(`[${scriptName}] failed to start:`, err);
+                resolve({
+                    success: false,
+                    error: err.message
+                });
+            });
+        } catch (error) {
+            console.error(`[ERROR] Failed to run ${scriptName}:`, error);
+            resolve({
+                success: false,
+                error: error.message
+            });
+        }
+    });
+}
+
+/** Python 스크립트 실행 핸들러 */
+ipcMain.handle('python:run', async (event, options) => {
+    try {
+        // 이벤트 객체 전달하여 진행 상황을 해당 윈도우로 직접 전송할 수 있도록 함
+        options.event = event;
+        return await runPythonScript(options);
+    } catch (error) {
+        console.error('[ERROR] python:run handler error:', error);
+        return { success: false, error: error.message };
+    }
 });
\ No newline at end of file
diff --git a/project/preload-iqgen.js b/project/preload-iqgen.js
new file mode 100644
index 0000000..4f802ef
--- /dev/null
+++ b/project/preload-iqgen.js
@@ -0,0 +1,123 @@
+const { contextBridge, ipcRenderer } = require('electron');
+
+// 렌더러 프로세스에 노출할 API
+contextBridge.exposeInMainWorld('electronAPI', {
+    // 디렉토리 선택 대화상자 열기
+    openDirectoryDialog: (options) => ipcRenderer.invoke('dialog:openDirectory', options),
+
+    // 디렉토리 읽기 및 파일 목록 가져오기
+    readDirectory: (path) => ipcRenderer.invoke('fs:readDirectory', path),
+
+    // 디렉토리 존재 여부 확인
+    directoryExists: (path) => ipcRenderer.invoke('fs:directoryExists', path),
+
+    // 메시지 박스 표시
+    showMessageBox: (options) => ipcRenderer.invoke('dialog:showMessageBox', options),
+
+    // 이미지 파일 처리 (예: 경로로부터 이미지 로드)
+    processImages: (sourcePath, targetPath) => ipcRenderer.invoke('image:process', { sourcePath, targetPath }),
+
+    // 모델 배포
+    deployModel: (sourcePath, targetPath) => ipcRenderer.invoke('model:deploy', { sourcePath, targetPath }),
+
+    // Python 스크립트 실행 (dist_onnx.py 등)
+    runPythonScript: (options) => ipcRenderer.invoke('python:run', options),
+
+    // Python 스크립트 진행 상황 이벤트 리스너
+    onPythonScriptProgress: (callback) => {
+        // 기존 리스너 제거 후 새로 등록 (중복 등록 방지)
+        ipcRenderer.removeAllListeners('python:progress');
+
+        // 이벤트 리스너 등록 및 로깅 추가
+        console.log('Registering python:progress event listener');
+
+        ipcRenderer.on('python:progress', (_, data) => {
+            console.log('Received python:progress event:', data);
+            callback(data);
+        });
+    },
+
+    // 직접 IPC 이벤트 접근을 위한 인터페이스 추가
+    ipcRenderer: {
+        on: (channel, callback) => {
+            if (channel === 'python:progress') {
+                ipcRenderer.on(channel, callback);
+            }
+        },
+        removeListener: (channel, callback) => {
+            if (channel === 'python:progress') {
+                ipcRenderer.removeListener(channel, callback);
+            }
+        }
+    },
+
+    // 로그 메시지 전송
+    logMessage: (message) => ipcRenderer.send('log:message', message),
+
+    // 이미지 정렬 실행
+    alignImages: (baseLinePath, otherLinePath) => {
+        ipcRenderer.send('image:align', { baseLinePath, otherLinePath });
+    },
+
+    // 정렬 진행 상황 이벤트 리스너
+    onAlignmentProgress: (callback) => {
+        // 기존 리스너 제거 후 새로 등록 (중복 등록 방지)
+        ipcRenderer.removeAllListeners('alignment:progress');
+        ipcRenderer.on('alignment:progress', (_, progress) => callback(progress));
+    },
+
+    // 정렬 완료 이벤트 리스너
+    onAlignmentComplete: (callback) => {
+        // 기존 리스너 제거 후 새로 등록 (중복 등록 방지)
+        ipcRenderer.removeAllListeners('alignment:complete');
+        ipcRenderer.on('alignment:complete', (_, result) => callback(result));
+    },
+
+    // HPO ONNX 스크립트 실행
+    runHpoOnnx: (baseLinePath, otherLinePath) => {
+        // 디버그 로깅 추가
+        console.log('Sending HPO request for paths:', baseLinePath, otherLinePath);
+        ipcRenderer.send('hpo:run', { baseLinePath, otherLinePath });
+    },
+
+    // HPO 증강 진행 상황 이벤트 리스너
+    onAugmentationProgress: (callback) => {
+        // 기존 리스너 제거 후 새로 등록 (중복 등록 방지)
+        ipcRenderer.removeAllListeners('hpo:progress');
+        ipcRenderer.on('hpo:progress', (_, data) => {
+            console.log('Received HPO progress:', data);
+            callback(data);
+        });
+    },
+
+    // HPO 프로세스 상태 확인
+    checkHpoStatus: () => ipcRenderer.invoke('hpo:checkStatus'),
+
+    // HPO 프로세스 종료
+    killHpoProcess: () => ipcRenderer.invoke('hpo:kill'),
+
+    // 탭 전환 이벤트 리스너
+    onTabEvent: (callback) => {
+        // 기존 리스너 제거 후 새로 등록
+        ipcRenderer.removeAllListeners('tab:focus');
+        ipcRenderer.removeAllListeners('tab:activated');
+
+        // 탭 포커스 이벤트
+        ipcRenderer.on('tab:focus', () => {
+            console.log('Tab focus event received');
+            callback('focus');
+        });
+
+        // 탭 활성화 이벤트
+        ipcRenderer.on('tab:activated', () => {
+            console.log('Tab activated event received');
+            callback('activated');
+        });
+    }
+});
+
+// 페이지 로드 완료 시 로그 메시지 전송
+window.addEventListener('DOMContentLoaded', () => {
+    ipcRenderer.send('log:message', 'IQGen 페이지가 로드되었습니다.');
+    console.log('preload-iqgen.js: DOM이 로드되었습니다.');
+}); 
\ No newline at end of file
diff --git a/project/preload.js b/project/preload.js
index 446e87f..9667cdb 100644
--- a/project/preload.js
+++ b/project/preload.js
@@ -6,6 +6,40 @@ contextBridge.exposeInMainWorld('electronAPI', {
     saveConfig: (data) => ipcRenderer.invoke('save-config', data),
     loadResults: () => ipcRenderer.invoke('load-results'), // 이거 자체가 함수 결과를 바로 리턴하는 것이므로, {} 로 감싸서 여러 줄을 작성하면 return 값이 index.html 로 전달이 안됨
     getDashboardPreloadPath: () => ipcRenderer.invoke('get-dashboard-preload-path'),
+    getIQGenPreloadPath: () => ipcRenderer.invoke('getIQGenPreloadPath'),
+
+    // File system and dialog operations
+    openDirectoryDialog: (options) => ipcRenderer.invoke('dialog:openDirectory', options),
+    showMessageBox: (options) => ipcRenderer.invoke('dialog:showMessageBox', options),
+    readDirectory: (dirPath) => ipcRenderer.invoke('fs:readDirectory', dirPath),
+    directoryExists: (dirPath) => ipcRenderer.invoke('fs:directoryExists', dirPath),
+
+    // Model operations
+    deployModel: (options) => {
+        console.log('preload.js: deployModel called with options:', options);
+        if (!options) {
+            console.error('deployModel: options is null or undefined');
+            return ipcRenderer.invoke('model:deploy', {});
+        }
+
+        return ipcRenderer.invoke('model:deploy', options);
+    },
+
+    // HPO operations
+    checkHpoStatus: () => ipcRenderer.invoke('hpo:checkStatus'),
+    killHpoProcess: () => ipcRenderer.invoke('hpo:kill'),
+
+    // Python script execution
+    runPythonScript: (options) => ipcRenderer.invoke('python:run', options),
+
+    // Image processing
+    processImage: (options) => ipcRenderer.invoke('image:process', options),
+
+    // Alignment operations
+    alignImages: (baseLinePath, otherLinePath) => ipcRenderer.invoke('align:images', baseLinePath, otherLinePath),
+
+    // HPO operations
+    runHpoOnnx: (baseLinePath, otherLinePath) => ipcRenderer.invoke('hpo:runOnnx', baseLinePath, otherLinePath),
 
     // stdout/stderr/close/error 이벤트 실시간 수신
     onCommandStdout: (callback) => {
@@ -28,4 +62,31 @@ contextBridge.exposeInMainWorld('electronAPI', {
             callback(errMsg);
         });
     },
+
+    // Progress events
+    onAlignmentProgress: (callback) => {
+        ipcRenderer.on('alignment:progress', (event, progress) => {
+            callback(progress);
+        });
+    },
+    onAlignmentComplete: (callback) => {
+        ipcRenderer.on('alignment:complete', (event, result) => {
+            callback(result);
+        });
+    },
+    onAugmentationProgress: (callback) => {
+        ipcRenderer.on('augmentation:progress', (event, data) => {
+            callback(data);
+        });
+    },
+
+    // Tab events
+    onTabEvent: (callback) => {
+        ipcRenderer.on('tab:event', (event, eventType) => {
+            callback(eventType);
+        });
+    },
+
+    // For direct IPC communication
+    ipcRenderer: ipcRenderer
 });
\ No newline at end of file
diff --git a/project/python_scripts/colorjitter.py b/project/python_scripts/colorjitter.py
new file mode 100644
index 0000000..37e173c
--- /dev/null
+++ b/project/python_scripts/colorjitter.py
@@ -0,0 +1,311 @@
+import numpy as np
+import cv2
+from typing import Union, Tuple
+import random
+
+class ColorJitter:
+    """
+    A numpy implementation of torchvision.transforms.ColorJitter.
+    
+    Randomly changes the brightness, contrast, saturation and hue of an image.
+    Input image should be a numpy array with values in range 0-255 in RGB format.
+    """
+    
+    def __init__(
+        self,
+        brightness: Union[float, Tuple[float, float]] = 0,
+        contrast: Union[float, Tuple[float, float]] = 0,
+        saturation: Union[float, Tuple[float, float]] = 0,
+        hue: Union[float, Tuple[float, float]] = 0
+    ):
+        """
+        Args:
+            brightness (float or tuple): How much to jitter brightness. brightness_factor is chosen 
+                uniformly from [max(0, 1 - brightness), 1 + brightness] or the given [min, max].
+                Should be non-negative numbers.
+            contrast (float or tuple): How much to jitter contrast. contrast_factor is chosen
+                uniformly from [max(0, 1 - contrast), 1 + contrast] or the given [min, max].
+                Should be non-negative numbers.
+            saturation (float or tuple): How much to jitter saturation. saturation_factor is chosen
+                uniformly from [max(0, 1 - saturation), 1 + saturation] or the given [min, max].
+                Should be non-negative numbers.
+            hue (float or tuple): How much to jitter hue. hue_factor is chosen uniformly from
+                [-hue, hue] or the given [min, max]. Should have 0 <= hue <= 0.5 or 
+                -0.5 <= min <= max <= 0.5.
+        """
+        self.brightness = self._check_input(brightness, 'brightness')
+        self.contrast = self._check_input(contrast, 'contrast')
+        self.saturation = self._check_input(saturation, 'saturation')
+        self.hue = self._check_input(hue, 'hue', center=0, bound=(-0.5, 0.5), is_hue=True)
+    
+    def _check_input(self, value, name, center=1, bound=(0, float('inf')), is_hue=False):
+        """
+        Check if the input value is valid and convert to a tuple range if necessary.
+        
+        Args:
+            value: Input value (float or tuple)
+            name: Parameter name for error messages
+            center: Center value for the range
+            bound: Acceptable bounds for the values
+            is_hue: Whether this is the hue parameter, which has special handling
+            
+        Returns:
+            Tuple of (min, max) values for the transformation
+        """
+        if isinstance(value, (list, tuple)):
+            if len(value) != 2:
+                raise ValueError(f"{name} should be a float or a tuple of two floats")
+            
+            if not bound[0] <= value[0] <= value[1] <= bound[1]:
+                raise ValueError(f"{name} values should be between {bound[0]} and {bound[1]}, got {value}")
+                
+            return value
+        
+        if not isinstance(value, (int, float)):
+            raise TypeError(f"{name} should be a float or a tuple of two floats, got {type(value)}")
+            
+        if value < 0:
+            raise ValueError(f"{name} should be non-negative, got {value}")
+            
+        if is_hue:
+            if not 0 <= value <= 0.5:
+                raise ValueError(f"{name} should be between 0 and 0.5, got {value}")
+            return (-value, value)
+        
+        # For brightness, contrast, saturation:
+        # If value is 0, return (center, center) which means no change
+        if value == 0:
+            return (center, center)
+        
+        # Generate range according to torchvision docs:
+        # Factor is chosen uniformly from [max(0, 1 - param), 1 + param]
+        min_val = max(0, center - value)
+        max_val = center + value
+        
+        return (min_val, max_val)
+    
+    def _get_params(self):
+        """
+        Get random parameters for the transforms to apply.
+        
+        Returns:
+            Dictionary of transformation parameters
+        """
+        transforms = []
+        
+        # Get all possible transforms
+        if self.brightness[0] != self.brightness[1]:
+            transforms.append('brightness')
+        if self.contrast[0] != self.contrast[1]:
+            transforms.append('contrast')
+        if self.saturation[0] != self.saturation[1]:
+            transforms.append('saturation')
+        if self.hue[0] != self.hue[1]:
+            transforms.append('hue')
+        
+        # Randomly shuffle the order of transforms
+        random.shuffle(transforms)
+        
+        params = {'transforms': transforms}
+        
+        # Generate random factors for each transform
+        if 'brightness' in transforms:
+            params['brightness_factor'] = random.uniform(self.brightness[0], self.brightness[1])
+        
+        if 'contrast' in transforms:
+            params['contrast_factor'] = random.uniform(self.contrast[0], self.contrast[1])
+        
+        if 'saturation' in transforms:
+            params['saturation_factor'] = random.uniform(self.saturation[0], self.saturation[1])
+        
+        if 'hue' in transforms:
+            params['hue_factor'] = random.uniform(self.hue[0], self.hue[1])
+            
+        return params
+    
+    def _adjust_brightness(self, img, brightness_factor):
+        """
+        Adjust brightness of an image.
+        
+        Args:
+            img: Numpy array image (0-255 range) in RGB format
+            brightness_factor: Factor to adjust brightness
+            
+        Returns:
+            Brightness adjusted image
+        """
+        return np.clip(img * brightness_factor, 0, 255).astype(np.uint8)
+    
+    def _adjust_contrast(self, img, contrast_factor):
+        """
+        Adjust contrast of an image.
+        
+        Args:
+            img: Numpy array image (0-255 range) in RGB format
+            contrast_factor: Factor to adjust contrast
+            
+        Returns:
+            Contrast adjusted image
+        """
+        # Calculate the mean across spatial dimensions and channels
+        mean = np.mean(img, axis=(0, 1), keepdims=True)
+        
+        # Apply contrast adjustment and clip to valid range
+        return np.clip((img - mean) * contrast_factor + mean, 0, 255).astype(np.uint8)
+    
+    def _adjust_saturation(self, img, saturation_factor):
+        """
+        Adjust saturation of an image.
+        
+        Args:
+            img: Numpy array image (0-255 range) in RGB format
+            saturation_factor: Factor to adjust saturation
+            
+        Returns:
+            Saturation adjusted image
+        """
+        # Convert to HSV
+        hsv_img = cv2.cvtColor(img, cv2.COLOR_RGB2HSV)
+        
+        # Adjust S channel
+        hsv_img[:, :, 1] = np.clip(hsv_img[:, :, 1] * saturation_factor, 0, 255).astype(np.uint8)
+        
+        # Convert back to RGB
+        return cv2.cvtColor(hsv_img, cv2.COLOR_HSV2RGB)
+    
+    def _adjust_hue(self, img, hue_factor):
+        """
+        Adjust hue of an image.
+        
+        Args:
+            img: Numpy array image (0-255 range) in RGB format
+            hue_factor: Factor to adjust hue
+            
+        Returns:
+            Hue adjusted image
+        """
+        # Convert to HSV
+        hsv_img = cv2.cvtColor(img, cv2.COLOR_RGB2HSV).astype(np.int16)
+        
+        # Adjust H channel (hue)
+        # OpenCV uses H values in range [0, 180], so scale the factor
+        hsv_img[:, :, 0] = (hsv_img[:, :, 0] + int(hue_factor * 180)) % 180
+        
+        # Convert back to uint8 and then to RGB
+        hsv_img = hsv_img.astype(np.uint8)
+        return cv2.cvtColor(hsv_img, cv2.COLOR_HSV2RGB)
+
+    def apply(self, img, params=None):
+        """
+        Apply color jitter transformation to a single image.
+        
+        Args:
+            img: Numpy array image (0-255 range) in RGB format
+            params: Optional transformation parameters. If None, random params are generated.
+            
+        Returns:
+            Transformed image
+        """
+        if params is None:
+            params = self._get_params()
+        
+        result = img.copy()
+        
+        for t in params['transforms']:
+            if t == 'brightness':
+                result = self._adjust_brightness(result, params['brightness_factor'])
+            elif t == 'contrast':
+                result = self._adjust_contrast(result, params['contrast_factor'])
+            elif t == 'saturation':
+                result = self._adjust_saturation(result, params['saturation_factor'])
+            elif t == 'hue':
+                result = self._adjust_hue(result, params['hue_factor'])
+        
+        return result
+    
+    def apply_batch(self, imgs, same_across_batch=True):
+        """
+        Apply color jitter transformation to a batch of images.
+        
+        Args:
+            imgs: Batch of numpy array images (B, H, W, C) with values in range 0-255 in RGB format
+            same_across_batch: Whether to apply the same transformation to all images in the batch
+            
+        Returns:
+            Transformed batch of images
+        """
+        batch_size = imgs.shape[0]
+        
+        if same_across_batch:
+            # Generate one set of params for consistency across the batch
+            params = self._get_params()
+            
+            # Process the batch more efficiently for brightness and contrast
+            # which can be vectorized
+            curr_batch = imgs.copy()
+            
+            for t in params['transforms']:
+                if t == 'brightness':
+                    # Vectorized brightness adjustment
+                    curr_batch = np.clip(curr_batch * params['brightness_factor'], 0, 255).astype(np.uint8)
+                elif t == 'contrast':
+                    # Vectorized contrast adjustment (per image)
+                    mean = np.mean(curr_batch, axis=(1, 2), keepdims=True)
+                    curr_batch = np.clip((curr_batch - mean) * params['contrast_factor'] + mean, 0, 255).astype(np.uint8)
+                elif t == 'saturation' or t == 'hue':
+                    # For saturation and hue, we need to process each image individually
+                    # since cv2 color conversions don't work directly on batches
+                    for i in range(batch_size):
+                        if t == 'saturation':
+                            curr_batch[i] = self._adjust_saturation(curr_batch[i], params['saturation_factor'])
+                        elif t == 'hue':
+                            curr_batch[i] = self._adjust_hue(curr_batch[i], params['hue_factor'])
+            
+            return curr_batch
+        else:
+            # Apply different transformations to each image
+            result = np.zeros_like(imgs)
+            for i in range(batch_size):
+                result[i] = self.apply(imgs[i])
+            return result
+    
+    def __call__(self, img):
+        """
+        Apply color jitter transformation to an image or batch of images.
+        
+        Args:
+            img: Numpy array image (H, W, C) or batch of images (B, H, W, C) with values in range 0-255 in RGB format
+            
+        Returns:
+            Transformed image(s)
+        """
+        # Check if the input is a batch
+        is_batch = len(img.shape) == 4
+        
+        if is_batch:
+            # By default, apply the same transformation across the batch for consistency
+            return self.apply_batch(img, same_across_batch=True)
+        else:
+            return self.apply(img)
+
+
+# Example usage:
+if __name__ == "__main__":
+    # Create a ColorJitter instance
+    color_jitter = ColorJitter(
+        brightness=0.4,
+        contrast=0.4,
+        saturation=0.4,
+        hue=0.1
+    )
+    
+    # Load an example image (using OpenCV)
+    # Note: OpenCV loads images in BGR format, so convert to RGB
+    # img = cv2.cvtColor(cv2.imread('example.jpg'), cv2.COLOR_BGR2RGB)
+    
+    # Apply color jitter transformation
+    # jittered_img = color_jitter(img)
+    
+    # For batch processing:
+    # batch_imgs = np.stack([img1, img2, img3])
+    # jittered_batch = color_jitter(batch_imgs)
\ No newline at end of file
diff --git a/project/python_scripts/common.py b/project/python_scripts/common.py
new file mode 100644
index 0000000..6db9874
--- /dev/null
+++ b/project/python_scripts/common.py
@@ -0,0 +1,525 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+import numpy as np
+import math
+import torch
+import tqdm
+import os
+import pickle
+import faiss
+import abc
+from typing import List, Union
+from torch import nn
+from torchvision.datasets import ImageFolder
+
+def init_weight(m):
+
+    if isinstance(m, torch.nn.Linear):
+        torch.nn.init.xavier_normal_(m.weight)
+    elif isinstance(m, torch.nn.Conv2d):
+        torch.nn.init.xavier_normal_(m.weight)
+
+def get_memory_bank_manager(coreset_ratio=None, device=None):
+    return MemoryBankManager(coreset_ratio, device)
+
+class MemoryBankManager:
+    def __init__(self, coreset_ratio=None, device=None):
+        self.anomaly_scorer = NearestNeighbourScorer(
+            n_nearest_neighbours=1, nn_method=FaissNN(False, 8))
+        if device is None:
+            self.featuresampler = None
+        else:
+            self.featuresampler = ApproximateGreedyCoresetSampler(coreset_ratio, device)
+
+    def fill_memory_bank(self, features):
+        """Computes and sets the support features for SPADE."""
+        features = np.concatenate(features, axis=0)
+        features = self.featuresampler.run(features)
+
+        self.anomaly_scorer.fit(detection_features=[features])
+
+    def save(self, save_folder, patch_shape):
+        self.anomaly_scorer.save(save_folder)
+        # save patch_shape (tuple)
+        with open(os.path.join(save_folder, 'patch_shape.pkl'), 'wb') as f:
+            pickle.dump(patch_shape, f)
+    
+    def load(self, load_folder):
+        self.anomaly_scorer.load(load_folder)
+        with open(os.path.join(load_folder, 'patch_shape.pkl'), 'rb') as f:
+            self.patch_shape = pickle.load(f)
+    
+    def predict(self, features, patch_shape=None):
+        if patch_shape is not None:
+            self.patch_shape = patch_shape
+        scores = self.anomaly_scorer.predict([features])[0]
+        return scores.reshape(1, *(self.patch_shape[0])) # NOTE 앞에 1은 inference() 내부 m = m[0, ...] 에 대응하기 위한 변환
+
+    def predict_no_reshape(self, features):
+        scores = self.anomaly_scorer.predict([features])[0]
+        # reshape 없이 반환
+        return scores
+
+
+class PatchMaker:
+    def __init__(self, patchsize, top_k=0, stride=None):
+        self.patchsize = patchsize
+        self.stride = stride
+        self.top_k = top_k
+
+    def patchify(self, features, return_spatial_info=False):
+        """Convert a tensor into a tensor of respective patches.
+        Args:
+            x: [torch.Tensor, bs x c x w x h]
+        Returns:
+            x: [torch.Tensor, bs * w//stride * h//stride, c, patchsize,
+            patchsize]
+        """
+        padding = int((self.patchsize - 1) / 2)
+        # features.shape == torch.Size([8, 512, 36, 36])
+        unfolder = torch.nn.Unfold(
+            kernel_size=self.patchsize, stride=self.stride, padding=padding, dilation=1
+        )  # Unfold(kernel_size=3, dilation=1, padding=1, stride=1)
+
+        # unfolded_features == torch.Size([8, 4608, 1296]) == [B, 3*3*512, 36*36] NOTE 즉 patch 간 겹치는 부분이 큼
+        unfolded_features = unfolder(features)
+        number_of_total_patches = []
+        for s in features.shape[-2:]:
+            n_patches = (
+                s + 2 * padding - 1 * (self.patchsize - 1) - 1
+            ) / self.stride + 1
+            number_of_total_patches.append(int(n_patches))
+
+        unfolded_features = unfolded_features.reshape(
+            *features.shape[:2], self.patchsize, self.patchsize, -1
+        )
+        # unfolded_features == torch.Size([8, 512, 3, 3, 1296])
+        unfolded_features = unfolded_features.permute(0, 4, 1, 2, 3)
+
+        if return_spatial_info:
+            return unfolded_features, number_of_total_patches
+        return unfolded_features
+
+    def unpatch_scores(self, x, batchsize):
+        return x.reshape(batchsize, -1, *x.shape[1:])
+
+    def score(self, x):
+        was_numpy = False
+        if isinstance(x, np.ndarray):
+            was_numpy = True
+            x = torch.from_numpy(x)
+        while x.ndim > 2:
+            x = torch.max(x, dim=-1).values
+        if x.ndim == 2:
+            if self.top_k > 1:
+                x = torch.topk(x, self.top_k, dim=1).values.mean(1)
+            else:
+                x = torch.max(x, dim=1).values
+        if was_numpy:
+            return x.numpy()
+        return x
+
+
+def get_patchmaker(patchsize=3, stride=1):
+    return PatchMaker(patchsize, stride=stride)
+
+class ImageFolderWithoutTarget(ImageFolder):
+    def __getitem__(self, index):
+        sample, target = super().__getitem__(index)
+        return sample
+
+class ImageFolderWithPath(ImageFolder):
+    def __getitem__(self, index):
+        path, target = self.samples[index]
+        sample, target = super().__getitem__(index)
+        return sample, target, path
+
+def InfiniteDataloader(loader):
+    iterator = iter(loader)
+    while True:
+        try:
+            yield next(iterator)
+        except StopIteration:
+            iterator = iter(loader)
+
+class NearestNeighbourScorer(object):
+    def __init__(self, n_nearest_neighbours: int, nn_method) -> None:
+        """
+        Neearest-Neighbourhood Anomaly Scorer class.
+
+        Args:
+            n_nearest_neighbours: [int] Number of nearest neighbours used to
+                determine anomalous pixels.
+            nn_method: Nearest neighbour search method.
+        """
+        self.feature_merger = ConcatMerger()
+
+        self.n_nearest_neighbours = n_nearest_neighbours
+        self.nn_method = nn_method
+
+        self.imagelevel_nn = lambda query: self.nn_method.run(
+            n_nearest_neighbours, query
+        )
+        self.pixelwise_nn = lambda query, index: self.nn_method.run(
+            1, query, index)
+
+    def fit(self, detection_features: List[np.ndarray]) -> None:
+        """Calls the fit function of the nearest neighbour method.
+
+        Args:
+            detection_features: [list of np.arrays]
+                [[bs x d_i] for i in n] Contains a list of
+                np.arrays for all training images corresponding to respective
+                features VECTORS (or maps, but will be resized) produced by
+                some backbone network which should be used for image-level
+                anomaly detection.
+        """
+        self.detection_features = self.feature_merger.merge(
+            detection_features,
+        )
+        self.nn_method.fit(self.detection_features)
+
+    def predict(
+        self, query_features: List[np.ndarray]
+    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:
+        """Predicts anomaly score.
+
+        Searches for nearest neighbours of test images in all
+        support training images.
+
+        Args:
+             detection_query_features: [dict of np.arrays] List of np.arrays
+                 corresponding to the test features generated by
+                 some backbone network.
+        """
+        query_features = self.feature_merger.merge(
+            query_features,
+        )
+        query_distances, query_nns = self.imagelevel_nn(query_features)
+        anomaly_scores = np.mean(query_distances, axis=-1)
+        return anomaly_scores, query_distances, query_nns
+
+    @staticmethod
+    def _detection_file(folder, prepend=""):
+        return os.path.join(folder, prepend + "nnscorer_features.pkl")
+
+    @staticmethod
+    def _index_file(folder, prepend=""):
+        return os.path.join(folder, prepend + "nnscorer_search_index.faiss")
+
+    @staticmethod
+    def _save(filename, features):
+        if features is None:
+            return
+        with open(filename, "wb") as save_file:
+            pickle.dump(features, save_file, pickle.HIGHEST_PROTOCOL)
+
+    @staticmethod
+    def _load(filename: str):
+        with open(filename, "rb") as load_file:
+            return pickle.load(load_file)
+
+    def save(
+        self,
+        save_folder: str,
+        save_features_separately: bool = False,
+        prepend: str = "",
+    ) -> None:
+        self.nn_method.save(self._index_file(save_folder, prepend))
+        if save_features_separately:
+            self._save(
+                self._detection_file(
+                    save_folder, prepend), self.detection_features
+            )
+
+    def save_and_reset(self, save_folder: str) -> None:
+        self.save(save_folder)
+        self.nn_method.reset_index()
+
+    def load(self, load_folder: str, prepend: str = "") -> None:
+        self.nn_method.load(self._index_file(load_folder, prepend))
+        if os.path.exists(self._detection_file(load_folder, prepend)):
+            self.detection_features = self._load(
+                self._detection_file(load_folder, prepend)
+            )
+
+
+class FaissNN(object):
+    def __init__(self, on_gpu: bool = False, num_workers: int = 4) -> None:
+        """FAISS Nearest neighbourhood search.
+
+        Args:
+            on_gpu: If set true, nearest neighbour searches are done on GPU.
+            num_workers: Number of workers to use with FAISS for similarity search.
+        """
+        faiss.omp_set_num_threads(num_workers)
+        self.on_gpu = on_gpu
+        self.search_index = None
+
+    def _gpu_cloner_options(self):
+        return faiss.GpuClonerOptions()
+
+    def _index_to_gpu(self, index):
+        if self.on_gpu:
+            # For the non-gpu faiss python package, there is no GpuClonerOptions
+            # so we can not make a default in the function header.
+            return faiss.index_cpu_to_gpu(
+                faiss.StandardGpuResources(), 0, index, self._gpu_cloner_options()
+            )
+        return index
+
+    def _index_to_cpu(self, index):
+        if self.on_gpu:
+            return faiss.index_gpu_to_cpu(index)
+        return index
+
+    def _create_index(self, dimension):
+        if self.on_gpu:
+            return faiss.GpuIndexFlatL2(
+                faiss.StandardGpuResources(), dimension, faiss.GpuIndexFlatConfig()
+            )
+        return faiss.IndexFlatL2(dimension)
+
+    def fit(self, features: np.ndarray) -> None:
+        """
+        Adds features to the FAISS search index.
+
+        Args:
+            features: Array of size NxD.
+        """
+        if self.search_index:
+            self.reset_index()
+        self.search_index = self._create_index(features.shape[-1])
+        self._train(self.search_index, features)
+        self.search_index.add(features)
+
+    def _train(self, _index, _features):
+        pass
+
+    def run(
+        self,
+        n_nearest_neighbours,
+        query_features: np.ndarray,
+        index_features: np.ndarray = None,
+    ) -> Union[np.ndarray, np.ndarray, np.ndarray]:
+        """
+        Returns distances and indices of nearest neighbour search.
+
+        Args:
+            query_features: Features to retrieve.
+            index_features: [optional] Index features to search in.
+        """
+        if index_features is None:
+            return self.search_index.search(query_features, n_nearest_neighbours)
+
+        # Build a search index just for this search.
+        search_index = self._create_index(index_features.shape[-1])
+        self._train(search_index, index_features)
+        search_index.add(index_features)
+        return search_index.search(query_features, n_nearest_neighbours)
+
+    def save(self, filename: str) -> None:
+        faiss.write_index(self._index_to_cpu(self.search_index), filename)
+
+    def load(self, filename: str) -> None:
+        self.search_index = self._index_to_gpu(faiss.read_index(filename))
+
+    def reset_index(self):
+        if self.search_index:
+            self.search_index.reset()
+            self.search_index = None
+
+
+class _BaseMerger:
+    def __init__(self):
+        """Merges feature embedding by name."""
+
+    def merge(self, features: list):
+        features = [self._reduce(feature) for feature in features]
+        return np.concatenate(features, axis=1)
+
+
+class ConcatMerger(_BaseMerger):
+    @staticmethod
+    def _reduce(features):
+        # NxCxWxH -> NxCWH
+        return features.reshape(len(features), -1)
+
+
+class BaseSampler(abc.ABC):
+    def __init__(self, percentage: float):
+        if not 0 < percentage <= 1:
+            raise ValueError("Percentage value not in (0, 1).")
+        self.percentage = percentage
+
+    @abc.abstractmethod
+    def run(
+        self, features: Union[torch.Tensor, np.ndarray]
+    ) -> Union[torch.Tensor, np.ndarray]:
+        pass
+
+    def _store_type(self, features: Union[torch.Tensor, np.ndarray]) -> None:
+        self.features_is_numpy = isinstance(features, np.ndarray)
+        if not self.features_is_numpy:
+            self.features_device = features.device
+
+    def _restore_type(self, features: torch.Tensor) -> Union[torch.Tensor, np.ndarray]:
+        if self.features_is_numpy:
+            return features.cpu().numpy()
+        return features.to(self.features_device)
+
+
+class GreedyCoresetSampler(BaseSampler):
+    def __init__(
+        self,
+        percentage: float,
+        device: torch.device,
+        dimension_to_project_features_to=128,
+    ):
+        """Greedy Coreset sampling base class."""
+        super().__init__(percentage)
+
+        self.device = device
+        self.dimension_to_project_features_to = dimension_to_project_features_to
+
+    def _reduce_features(self, features):
+        if features.shape[1] == self.dimension_to_project_features_to:
+            return features
+        mapper = torch.nn.Linear(
+            features.shape[1], self.dimension_to_project_features_to, bias=False
+        )
+        _ = mapper.to(self.device)
+        features = features.to(self.device)
+        return mapper(features)
+
+    def run(
+        self, features: Union[torch.Tensor, np.ndarray], return_indices=False
+    ) -> Union[torch.Tensor, np.ndarray]:
+        """Subsamples features using Greedy Coreset.
+
+        Args:
+            features: [N x D]
+        """
+        self._store_type(features)
+        if isinstance(features, np.ndarray):
+            features = torch.from_numpy(features)
+        """
+        (Pdb) p features.shape
+            torch.Size([235520, 1536])
+        """
+        reduced_features = self._reduce_features(features)
+        try:
+            sample_indices = self._compute_greedy_coreset_indices(reduced_features)
+        except:
+            sample_indices = self._compute_greedy_coreset_indices(reduced_features.cpu())
+
+        features = features[sample_indices]
+        if return_indices:
+            return self._restore_type(features), sample_indices
+        return self._restore_type(features)
+
+    @staticmethod
+    def _compute_batchwise_differences(
+        matrix_a: torch.Tensor, matrix_b: torch.Tensor
+    ) -> torch.Tensor:
+        """Computes batchwise Euclidean distances using PyTorch."""
+        a_times_a = matrix_a.unsqueeze(1).bmm(
+            matrix_a.unsqueeze(2)).reshape(-1, 1)
+        b_times_b = matrix_b.unsqueeze(1).bmm(
+            matrix_b.unsqueeze(2)).reshape(1, -1)
+        a_times_b = matrix_a.mm(matrix_b.T)
+
+        return (-2 * a_times_b + a_times_a + b_times_b).clamp(0, None).sqrt()
+
+    def _compute_greedy_coreset_indices(self, features: torch.Tensor) -> np.ndarray:
+        """Runs iterative greedy coreset selection.
+
+        Args:
+            features: [NxD] input feature bank to sample.
+        """
+        distance_matrix = self._compute_batchwise_differences(
+            features, features)
+        coreset_anchor_distances = torch.norm(distance_matrix, dim=1)
+
+        coreset_indices = []
+        num_coreset_samples = int(len(features) * self.percentage)
+
+        for _ in range(num_coreset_samples):
+            select_idx = torch.argmax(coreset_anchor_distances).item()
+            coreset_indices.append(select_idx)
+
+            coreset_select_distance = distance_matrix[
+                :, select_idx: select_idx + 1  # noqa E203
+            ]
+            coreset_anchor_distances = torch.cat(
+                [coreset_anchor_distances.unsqueeze(-1), coreset_select_distance], dim=1
+            )
+            coreset_anchor_distances = torch.min(
+                coreset_anchor_distances, dim=1).values
+
+        return np.array(coreset_indices)
+
+
+class ApproximateGreedyCoresetSampler(GreedyCoresetSampler):
+    def __init__(
+        self,
+        percentage: float,
+        device: torch.device,
+        number_of_starting_points: int = 10,
+        dimension_to_project_features_to: int = 128,
+        num_coreset_samples: int = None,
+    ):
+        """Approximate Greedy Coreset sampling base class."""
+        self.number_of_starting_points = number_of_starting_points
+        self.num_coreset_samples = num_coreset_samples
+        super().__init__(percentage, device, dimension_to_project_features_to)
+
+    def _compute_greedy_coreset_indices(self, features: torch.Tensor) -> np.ndarray:
+        """Runs approximate iterative greedy coreset selection.
+
+        This greedy coreset implementation does not require computation of the
+        full N x N distance matrix and thus requires a lot less memory, however
+        at the cost of increased sampling times.
+
+        Args:
+            features: [NxD] input feature bank to sample.
+        """
+        number_of_starting_points = np.clip(
+            self.number_of_starting_points, None, len(features)
+        )  # --> 10
+        start_points = np.random.choice(
+            len(features), number_of_starting_points, replace=False
+        ).tolist()  # --> 10 개 indices
+
+        approximate_distance_matrix = self._compute_batchwise_differences(
+            features, features[start_points]
+        )  # --> #features x 10 matrix 연산. e.g., torch.Size([458640, 10])
+
+        approximate_coreset_anchor_distances = torch.mean(
+            approximate_distance_matrix, axis=-1
+        ).reshape(-1, 1)  # --> torch.Size([458640, 1])
+        coreset_indices = []
+
+        num_coreset_samples = int(len(features) * self.percentage)
+        if self.num_coreset_samples is None:
+            pass
+        else:
+            num_coreset_samples = min(num_coreset_samples, int(self.num_coreset_samples))
+
+        with torch.no_grad():
+            for _ in tqdm.tqdm(range(num_coreset_samples), desc="Subsampling..."):
+                select_idx = torch.argmax(
+                    approximate_coreset_anchor_distances).item()  # 가장 큰 값의 index 1개
+                coreset_indices.append(select_idx)
+                coreset_select_distance = self._compute_batchwise_differences(
+                    features, features[select_idx: select_idx + 1]  # noqa: E203
+                )  # 방금 추출한 coresot index 와의 거리 계산
+                approximate_coreset_anchor_distances = torch.cat(
+                    [approximate_coreset_anchor_distances, coreset_select_distance],
+                    dim=-1,
+                )  # --> torch.Size([458640, 2])
+                approximate_coreset_anchor_distances = torch.min(
+                    approximate_coreset_anchor_distances, dim=1
+                ).values.reshape(-1, 1)  # --> torch.Size([458640, 1]) 둘 중에 작은 값으로 업데이트
+
+        return np.array(coreset_indices)
diff --git a/project/python_scripts/dist_onnx.py b/project/python_scripts/dist_onnx.py
new file mode 100644
index 0000000..04e5913
--- /dev/null
+++ b/project/python_scripts/dist_onnx.py
@@ -0,0 +1,553 @@
+import torch
+import torchvision.transforms as T
+from torch.utils.data import DataLoader, Dataset
+import numpy as np
+import onnxruntime
+import os
+import glob
+import shutil
+from PIL import Image
+from tqdm import tqdm
+import argparse
+import sys
+import json
+
+# 필요하다면 함께 사용
+from common import get_memory_bank_manager
+
+# Default constants that will be updated with command-line args
+RESIZE_SIZE = 256
+ANOMALY_MAP_FOLDER = "anomaly_maps"
+MEMORY_BANK_FOLDER = "memory_dist"
+MODEL_PATH = "models/model.onnx"
+NUM_WORKERS = 0
+TEST_RATIO = 0.2
+
+
+SAVE_DETAILS = '_anomaly_maps'
+
+# ImageNet mean and std
+IMAGENET_MEAN = [0.485, 0.456, 0.406]
+IMAGENET_STD = [0.229, 0.224, 0.225]
+USE_IMAGENET_NORM = True  # ImageNet 정규화 사용 플래그
+
+# 중앙 크롭 비율 (1.0 = 원본 크기 유지, 작을수록 더 많이 크롭)
+CENTER_CROP_RATE = 0.8
+
+# ----------------------------- 공통 유틸 ----------------------------- #
+
+def init_directories(*dirs):
+    for dir_path in dirs:
+        if os.path.exists(dir_path):
+            shutil.rmtree(dir_path)
+        os.makedirs(dir_path)
+
+def init_files(*files):
+    for file_path in files:
+        if os.path.exists(file_path):
+            os.remove(file_path)
+
+def get_image_paths(folder_path):
+    image_paths = []
+    for ext in ["png", "jpg", "jpeg", "bmp", "tif", "tiff"]:
+        image_paths += glob.glob(os.path.join(folder_path, f"*.{ext}"))
+    image_paths.sort()
+    return image_paths
+
+def report_progress(progress, status="processing"):
+    """
+    진행 상황을 Electron에 보고하는 함수
+    
+    매개변수:
+        progress: 0에서 100 사이의 진행률 
+        status: 현재 처리 상태 메시지
+    """
+    # JSON 형식으로 진행 상황 보고
+    progress_data = {
+        "progress": round(progress, 2),
+        "status": status
+    }
+    print(json.dumps(progress_data), flush=True)
+
+def calculate_image_statistics(folder_path):
+    """폴더 내 모든 이미지를 256×256으로 리사이즈한 뒤 채널 단위 mean / std 계산"""
+    dataset = TransformedDataset(folder_path, transform=None, resize=True)
+    loader  = DataLoader(dataset, batch_size=16, shuffle=False)
+
+    sum_c, sum_sq_c = torch.zeros(3), torch.zeros(3)
+    total_px = 0
+    for imgs, _ in tqdm(loader, desc=f"[통계 계산] {folder_path}"):
+        # Convert to proper format for calculation
+        imgs_chw = imgs.permute(0, 3, 1, 2).float() / 255.0
+        sum_c     += imgs_chw.sum(dim=[0, 2, 3])
+        sum_sq_c  += (imgs_chw ** 2).sum(dim=[0, 2, 3])
+        total_px  += imgs_chw.shape[0] * imgs_chw.shape[2] * imgs_chw.shape[3]
+
+    mean = sum_c / total_px
+    var  = sum_sq_c / total_px - mean**2
+    std  = torch.sqrt(var + 1e-8)
+    return mean, std
+
+# -------------------------- 데이터셋/트랜스폼 ------------------------- #
+
+class TransformedDataset(Dataset):
+    def __init__(
+        self,
+        folder_path,
+        transform=None,
+        resize=True,
+        limit=None,
+        seed=42,
+        mean=None,
+        std=None,
+        selected_paths=None,
+        train_split=None,
+    ):
+        if selected_paths is not None:
+            self.image_paths = selected_paths
+        else:
+            self.image_paths = get_image_paths(folder_path)
+            
+            
+            # Apply train/test split if specified
+            if train_split is not None:
+                # 파일명 기준으로 정렬 (오름차순)
+                self.image_paths.sort()
+                
+                split_idx = int(len(self.image_paths) * abs(train_split))
+                
+                if train_split > 0:  # Training set - 뒷부분 사용
+                    self.image_paths = self.image_paths[split_idx:]
+                else:  # Test set - 앞부분 사용 (1-train_split 비율)
+                    self.image_paths = self.image_paths[:split_idx]
+            
+            # Print the first and last image paths for debugging
+            if len(self.image_paths) > 0:
+                print(f"First image path: {self.image_paths[0]}")
+                if len(self.image_paths) > 1:
+                    print(f"Last image path: {self.image_paths[-1]}")
+
+            
+            # 항상 최종 경로 리스트 정렬
+            self.image_paths.sort()
+            
+            # Apply limit after splitting if specified
+            if limit is not None and len(self.image_paths) > limit:
+                np.random.seed(seed)
+                self.image_paths = np.random.choice(self.image_paths, limit, replace=False).tolist()
+                # 무작위 선택 후에도 정렬 유지
+                self.image_paths.sort()
+
+        self.transform = transform
+        self.resize = T.Resize((RESIZE_SIZE, RESIZE_SIZE)) if resize else None
+        self.mean, self.std = mean, std
+
+    def __len__(self):
+        return len(self.image_paths)
+
+    def __getitem__(self, idx):
+        img_path = self.image_paths[idx]
+        img = Image.open(img_path).convert("RGB")
+
+        # 중앙 크롭 적용
+        width, height = img.size
+        new_width = int(width * CENTER_CROP_RATE)
+        new_height = int(height * CENTER_CROP_RATE)
+        img = img.crop((
+            (width - new_width) // 2,
+            (height - new_height) // 2,
+            (width + new_width) // 2,
+            (height + new_height) // 2
+        ))
+
+        if self.transform:
+            img = self.transform(img)
+        
+        # T.ToTensor() 사용하지 않고 차원 순서 유지
+        if self.resize:
+            img = self.resize(img)
+            
+        # PIL 이미지를 numpy 배열로 변환 (H, W, C) 형식 유지
+        img_np = np.array(img)
+        
+        # numpy 배열을 torch 텐서로 변환 (H, W, C) 형식 유지
+        img_tensor = torch.from_numpy(img_np).float()
+
+        return img_tensor, img_path
+
+    def update_transform(self, new_transform):
+        """Transform을 업데이트하는 메서드"""
+        self.transform = new_transform
+        return self
+
+# -------------------------- ONNX 모델 관련 --------------------------- #
+
+def load_onnx_model(model_path):
+    """ONNX 모델을 GPU로 로드"""
+    onnx_model = onnxruntime.InferenceSession(
+        model_path,
+        providers=['CUDAExecutionProvider']
+        #providers=['CPUExecutionProvider']
+    )
+    return onnx_model
+
+def get_patch_features(model, img_tensor):
+    """ONNX 모델을 사용하여 특징을 추출"""
+    # ONNX 모델은 numpy 입력을 받으므로 변환
+    input_name = model.get_inputs()[0].name
+    ort_inputs = {input_name: img_tensor.numpy().astype(np.float32)}
+    ort_outputs = model.run(None, ort_inputs)
+    features = ort_outputs[0]  # 첫 번째 출력을 사용
+    return features
+
+def create_memory_bank(folder_paths, model, dataloaders, memory_bank_folder=MEMORY_BANK_FOLDER):
+    print("\n[메모리 뱅크 생성 중]")
+    report_progress(0, "메모리 뱅크 생성 중")
+    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
+    # 총 이미지 수 계산
+    total_images = sum(len(dl.dataset) for dl in dataloaders)
+
+    # 이미지당 패치 수 (32x32)
+    patches_per_image = 32 * 32
+    
+    # 총 패치 수 계산
+    total_patches = total_images * patches_per_image
+    
+    # 목표 subsampling 수 (10,000개)
+    target_samples = 10000
+    
+    # coreset_ratio 자동 계산 (최소 0.001, 최대 1.0으로 제한)
+    if total_patches > 0:
+        calculated_ratio = min(max(target_samples / total_patches, 0.001), 1.0)
+        coreset_ratio = calculated_ratio
+        print(f"총 이미지 수: {total_images}, 총 패치 수: {total_patches}")
+        print(f"목표 샘플 수: {target_samples}, 계산된 coreset_ratio: {coreset_ratio:.6f}")
+    else:
+        print("경고: 데이터셋이 비어 있습니다. 기본 coreset_ratio를 사용합니다.")
+
+    mb_mgr = get_memory_bank_manager(coreset_ratio, device)
+
+    features_all = []
+    
+    # 진행률 계산을 위한 변수
+    processed_images = 0
+    
+    for path_idx, (path, dl) in enumerate(zip(folder_paths, dataloaders)):
+        for batch_idx, (imgs, _) in enumerate(tqdm(dl, desc=f"> {path}")):
+            feats = get_patch_features(model, imgs)
+            features_all.append(feats)
+            
+            # 진행률 업데이트 (메모리 뱅크 생성은 전체 과정의 0-50% 차지)
+            processed_images += 1
+            progress = (processed_images / total_images) * 50
+            report_progress(progress, "메모리 뱅크 생성 중")
+
+    mb_mgr.fill_memory_bank(features_all)
+
+    # Patch shape 추론 & 저장
+    feat_side = int(np.sqrt(features_all[0].shape[0]))
+    mb_mgr.save(memory_bank_folder, [[feat_side, feat_side]])
+    print(f"메모리 뱅크 저장 완료: {memory_bank_folder}")
+    report_progress(50, "메모리 뱅크 생성 완료")
+    return mb_mgr
+
+def compute_top_anomaly_scores(dataloader, mb_mgr, model, top_percent=0.1):
+    scores = []
+    for imgs, paths in tqdm(dataloader, desc="[Anomaly Score]"):
+        anom_map, _ = compute_anomaly_map(imgs, mb_mgr, model)
+        flat = anom_map.flatten()
+        k    = int(len(flat) * top_percent)
+        topk = np.partition(flat, -k)[-k:]
+        scores.append({"image_path": paths[0], "top_mean_score": float(np.mean(topk))})
+
+    return scores
+
+def compute_anomaly_map(img_tensor, mb_mgr, model, reshape=True):
+    feats = get_patch_features(model, img_tensor)
+    if reshape:
+        scores = mb_mgr.predict(feats, [[32, 32]]).squeeze(0) # 내부 *(self.patch_shape[0]) 에 대응하기 위함
+    else:
+        scores = mb_mgr.predict_no_reshape(feats)
+    return scores, feats
+
+# ------------------------------- Class A ----------------------------- #
+
+class A:
+    def __init__(self, root="", line_a_path="", line_b_path="", gap=0.0):
+        # 경로 설정
+        self.root = root
+        self.line_a_path = line_a_path
+        self.line_b_path = line_b_path
+        self.gap = gap  # GAP 값을 인스턴스 변수로 저장
+
+        # 폴더 및 모델 경로 설정
+        self.anomaly_map_folder = os.path.join(root, ANOMALY_MAP_FOLDER)
+        self.memory_bank_folder = os.path.join(root, MEMORY_BANK_FOLDER)
+        self.model_path = os.path.join(root, MODEL_PATH)
+
+
+        # 라인별 anomaly_map 저장 디렉토리 생성
+        # 경로 끝의 슬래시 제거 후 SAVE_DETAILS 추가
+        a_test_anomaly_dir = f"{self.line_a_path.rstrip('/')}{SAVE_DETAILS}"
+        b_test_anomaly_dir = f"{self.line_b_path.rstrip('/')}{SAVE_DETAILS}"
+        self.a_test_anomaly_dir = a_test_anomaly_dir
+        self.b_test_anomaly_dir = b_test_anomaly_dir
+
+        # 디렉토리 초기화
+        init_directories(self.anomaly_map_folder, self.memory_bank_folder, a_test_anomaly_dir, b_test_anomaly_dir)
+
+        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
+        self.model = load_onnx_model(self.model_path)
+
+        # ONNX 모델은 이미 정규화가 포함되어 있으므로 0-1 범위로만 변환 (정규화 생략)
+        print("ONNX 모델은 이미 ImageNet 정규화가 포함되어 있어 추가 정규화를 생략합니다.")
+        self.folder_a_mean = None
+        self.folder_a_std = None
+        self.folder_b_mean = None
+        self.folder_b_std = None
+        
+        print(f"CENTER_CROP_RATE: {CENTER_CROP_RATE}")
+        print(f"LOCAL_FOLDER_A: {line_a_path}")
+        print(f"LOCAL_FOLDER_B: {line_b_path}")
+        
+        # 데이터셋 초기화 - 8:2 비율로 train/test 분할
+        self.test_ratio = TEST_RATIO
+        
+        # A 라인 데이터셋 (train/test)
+        self.ds_a_training = TransformedDataset(
+            line_a_path,
+            transform=None,
+            resize=True,
+            mean=self.folder_a_mean,
+            std=self.folder_a_std,
+            train_split=self.test_ratio
+        )
+        
+        self.ds_a_test = TransformedDataset(
+            line_a_path,
+            transform=None,
+            resize=True,
+            mean=self.folder_a_mean,
+            std=self.folder_a_std,
+            train_split=-self.test_ratio  # 음수 값은 test set을 의미
+        )
+        
+        # B 라인 데이터셋 (train/test)
+        self.ds_b_training = TransformedDataset(
+            line_b_path,
+            transform=None,
+            resize=True,
+            mean=self.folder_b_mean,
+            std=self.folder_b_std,
+            train_split=self.test_ratio
+        )
+        
+        self.ds_b_test = TransformedDataset(
+            line_b_path,
+            transform=None,
+            resize=True,
+            mean=self.folder_b_mean,
+            std=self.folder_b_std,
+            train_split=-self.test_ratio  # 음수 값은 test set을 의미
+        )
+        
+        # 컬러 변환된 데이터셋 (초기 transform은 None으로 설정)
+        self.ds_a_color = TransformedDataset(
+            line_a_path,
+            transform=None,
+            resize=True,
+            mean=None,
+            std=None,
+            selected_paths=self.ds_a_training.image_paths.copy()  # 동일한 이미지 사용
+        )
+
+    # --------------------------- 핵심 함수 --------------------------- #
+    def func(self, brightness: float = 0.0, contrast: float = 0.0, saturation: float = 0.0, hue: float = 0.0) -> float:
+        """
+        1) A_TRAIN_COLOR 생성: A_TRAIN 각 이미지에 ColorJitter 파라미터 내에서 랜덤한 색상 변환 적용
+        2) A_TRAIN + A_TRAIN_COLOR 로 메모리 뱅크 생성
+        3) 차이 점수 계산: B_TEST와 A_TEST 간의 anomaly score 차이 계산 후 반환
+        
+        Args:
+            brightness: 밝기 변화 최대 강도 (0: 변화 없음, 값이 클수록 더 큰 변화 가능성)
+            contrast: 대비 변화 최대 강도 (0: 변화 없음, 값이 클수록 더 큰 변화 가능성)
+            saturation: 채도 변화 최대 강도 (0: 변화 없음, 값이 클수록 더 큰 변화 가능성)
+            hue: 색조 변화 최대 강도 (0: 변화 없음, 값이 클수록 더 큰 변화 가능성)
+
+        HPO 파라미터 범위 추천:
+        - brightness: 0.0 ~ 0.5
+        - contrast: 0.0 ~ 0.5
+        - saturation: 0.0 ~ 0.5
+        - hue: 0.0 ~ 0.2
+        
+        Returns:
+            float: B_TEST와 A_TEST 간의 anomaly score 차이
+
+        """
+        # 초기 진행 상황 보고
+        report_progress(0, "시작")
+        
+        print(f"ColorJitter 파라미터: brightness={brightness}, contrast={contrast}, saturation={saturation}, hue={hue}")
+        
+        # 결과 저장용 디렉토리 생성
+        os.makedirs(self.memory_bank_folder, exist_ok=True)
+        os.makedirs(self.anomaly_map_folder, exist_ok=True)
+
+        # 이미지 경로 명시적으로 정렬 (파일명 기준 오름차순)
+        self.ds_a_test.image_paths.sort()
+        self.ds_b_test.image_paths.sort()
+
+        # A_TRAIN 및 A_TEST 데이터로더 생성
+        dl_a_training = DataLoader(self.ds_a_training, batch_size=1, shuffle=False, num_workers=NUM_WORKERS)
+        dl_a_test = DataLoader(self.ds_a_test, batch_size=1, shuffle=False, num_workers=NUM_WORKERS)
+        
+        # B_TEST 데이터로더 생성
+        dl_b_test = DataLoader(self.ds_b_test, batch_size=1, shuffle=False, num_workers=NUM_WORKERS)
+        
+        # --- 메모리 뱅크 생성 --- #
+        # 모든 컬러 파라미터가 0이면 ColorJitter 적용하지 않음
+        if brightness == 0.0 and contrast == 0.0 and saturation == 0.0 and hue == 0.0:
+            print("모든 ColorJitter 파라미터가 0입니다. ColorJitter를 제외합니다.")
+            mb_mgr = create_memory_bank(
+                [self.line_a_path],
+                self.model,
+                [dl_a_training],
+                memory_bank_folder=self.memory_bank_folder,
+            )
+        else:
+            # A_COLOR transform 업데이트 (init에서 생성된 데이터셋 재사용)
+            color_tf = T.ColorJitter(brightness=brightness, contrast=contrast, saturation=saturation, hue=hue)
+            self.ds_a_color.update_transform(color_tf)
+            dl_a_color = DataLoader(self.ds_a_color, batch_size=1, shuffle=False, num_workers=NUM_WORKERS)
+            
+            mb_mgr = create_memory_bank(
+                [self.line_a_path, f"{self.line_a_path}_COLOR1", f"{self.line_a_path}_COLOR2", f"{self.line_a_path}_COLOR3"],
+                self.model,
+                [dl_a_training, dl_a_color, dl_a_color, dl_a_color],
+                memory_bank_folder=self.memory_bank_folder,
+            )
+
+        # --- A_TEST에 대한 anomaly map 및 점수 계산 --- #
+        a_test_anomaly_maps = []
+        a_test_scores = []
+        
+        report_progress(50, "Anomaly Maps 생성 중")
+        total_a_test = len(dl_a_test.dataset)
+        
+        for idx, (imgs, paths) in enumerate(tqdm(dl_a_test, desc="[A_TEST Anomaly Maps]")):
+            anom_map, _ = compute_anomaly_map(imgs, mb_mgr, self.model)
+            a_test_anomaly_maps.append((anom_map, paths[0]))
+            a_test_scores.append(np.max(anom_map))
+            
+            # 진행률 업데이트 (A_TEST는 50-75% 구간)
+            progress = 50 + ((idx + 1) / total_a_test) * 25
+            report_progress(progress, "Anomaly Maps 생성 중")
+        
+        # A_TEST의 최대 anomaly score 계산
+        a_test_max_score = np.max(a_test_scores) if a_test_scores else 0.0
+        mean_score_a = float(np.mean(a_test_scores)) if a_test_scores else 0.0
+        print(f"A_TEST 최대 점수: {a_test_max_score}")
+        print(f"A_TEST 평균 점수: {mean_score_a}")
+        a_test_max_score = a_test_max_score + self.gap
+        
+        # A_TEST anomaly map을 바이너리 마스크로 변환하여 저장
+        for anom_map, img_path in a_test_anomaly_maps:
+            # 원본 이미지 로드하여 크기 확인
+            original_img = Image.open(img_path)
+            
+            # 먼저 anomaly map을 bilinear 보간법으로 원본 이미지 크기로 확대
+            anom_map_img = Image.fromarray(anom_map)
+            anom_map_img = anom_map_img.resize((original_img.size[0], original_img.size[1]), Image.BILINEAR)
+            anom_map_resized = np.array(anom_map_img)
+            
+            # 보간된 anomaly map에 대해 바이너리 마스크 생성: max 값보다 낮으면 0, 높거나 같으면 1
+            binary_mask = (anom_map_resized >= a_test_max_score).astype(np.uint8) * 255
+            
+            # 저장할 파일 경로 생성
+            filename = os.path.basename(img_path)
+            save_path = os.path.join(self.a_test_anomaly_dir, filename)
+            
+            # 바이너리 마스크 저장
+            Image.fromarray(binary_mask).save(save_path)
+        
+        # --- B_TEST에 대한 anomaly map 및 점수 계산 --- #
+        b_test_anomaly_maps = []
+        b_test_scores = []
+        
+        report_progress(75, "Anomaly Maps 생성 중")
+        total_b_test = len(dl_b_test.dataset)
+        
+        for idx, (imgs, paths) in enumerate(tqdm(dl_b_test, desc="[B_TEST Anomaly Maps]")):
+            anom_map, _ = compute_anomaly_map(imgs, mb_mgr, self.model)
+            b_test_anomaly_maps.append((anom_map, paths[0]))
+            b_test_scores.append(np.max(anom_map))
+            
+            # 진행률 업데이트 (B_TEST는 75-100% 구간)
+            progress = 75 + ((idx + 1) / total_b_test) * 25
+            report_progress(progress, "Anomaly Maps 생성 중")
+        
+        mean_score_b = float(np.mean(b_test_scores)) if b_test_scores else 0.0
+        print(f"B_TEST 평균 점수: {mean_score_b}")
+        
+        # B_TEST anomaly map을 바이너리 마스크로 변환하여 저장
+        for anom_map, img_path in b_test_anomaly_maps:
+            # 원본 이미지 로드하여 크기 확인
+            original_img = Image.open(img_path)
+            
+            # 먼저 anomaly map을 bilinear 보간법으로 원본 이미지 크기로 확대
+            anom_map_img = Image.fromarray(anom_map)
+            anom_map_img = anom_map_img.resize((original_img.size[0], original_img.size[1]), Image.BILINEAR)
+            anom_map_resized = np.array(anom_map_img)
+            
+            # 보간된 anomaly map에 대해 바이너리 마스크 생성: max 값보다 낮으면 0, 높거나 같으면 1
+            binary_mask = (anom_map_resized >= a_test_max_score).astype(np.uint8) * 255
+            
+            # 저장할 파일 경로 생성
+            filename = os.path.basename(img_path)
+            save_path = os.path.join(self.b_test_anomaly_dir, filename)
+            
+            # 바이너리 마스크 저장
+            Image.fromarray(binary_mask).save(save_path)
+
+        # B_TEST와 A_TEST 간의 차이 반환
+        score_diff = mean_score_b - mean_score_a
+        print(f"차이 점수: {score_diff}")
+        
+        # 완료 메시지 전송
+        report_progress(100, "완료")
+        
+        return -score_diff # 최소화 문제로 변환
+
+def main():
+    # 명령줄 인수 파싱
+    parser = argparse.ArgumentParser(description='HPO ONNX 도구')
+    parser.add_argument('line_a_path', help='첫 번째 이미지 라인 폴더 경로')
+    parser.add_argument('line_b_path', help='두 번째 이미지 라인 폴더 경로')
+    parser.add_argument('--root', default="", help='root 폴더')
+    parser.add_argument('--brightness', type=float, default=0, help='밝기 변화 강도')
+    parser.add_argument('--contrast', type=float, default=0, help='대비 변화 강도')
+    parser.add_argument('--saturation', type=float, default=0, help='채도 변화 강도')
+    parser.add_argument('--hue', type=float, default=0, help='색조 변화 강도')
+    parser.add_argument('--gap', type=float, default=0.0)
+    
+    args = parser.parse_args()
+
+    # A 클래스 인스턴스 생성
+    a = A(root=args.root, line_a_path=args.line_a_path, line_b_path=args.line_b_path, gap=args.gap)
+    
+    # func 함수 호출하여 결과 출력
+    result = a.func(
+        brightness=args.brightness,
+        contrast=args.contrast, 
+        saturation=args.saturation,
+        hue=args.hue
+    )
+    
+    print(f"결과: {result}")
+    
+    return result
+
+# ------------------------------ 실행 예시 ----------------------------- #
+
+if __name__ == "__main__":
+    main()
diff --git a/project/python_scripts/hpo_client.py b/project/python_scripts/hpo_client.py
new file mode 100644
index 0000000..c7d689e
--- /dev/null
+++ b/project/python_scripts/hpo_client.py
@@ -0,0 +1,483 @@
+import requests
+import datetime
+import time
+import json
+import argparse
+import random
+import sys
+import traceback
+import signal
+import os
+import atexit
+import multiprocessing as mp
+from multiprocessing import Process, Queue
+#from main_simple_torch_normalize_each_anomalymap_shift_c import A
+from hpo_onnx import A
+
+# 전역 변수로 프로세스 리스트 관리
+child_processes = []
+
+def cleanup_processes():
+    """
+    모든 자식 프로세스를 정리하는 함수
+    """
+    global child_processes
+    
+    print("[Main] 모든 자식 프로세스 종료 중...", file=sys.stderr)
+    for p in child_processes:
+        if p.is_alive():
+            try:
+                p.terminate()
+                p.join(timeout=1)
+                
+                # 여전히 살아있으면 강제 종료
+                if p.is_alive():
+                    print(f"[Main] 프로세스 {p.pid} 강제 종료 중...", file=sys.stderr)
+                    os.kill(p.pid, signal.SIGKILL)
+            except Exception as e:
+                print(f"[Main] 프로세스 종료 중 오류 발생: {e}", file=sys.stderr)
+    
+    print("[Main] 모든 자식 프로세스 종료 완료", file=sys.stderr)
+
+def signal_handler(sig, frame):
+    """
+    시그널 핸들러
+    """
+    print(f"\n[Main] 시그널 {sig} 수신, 프로그램을 종료합니다.", file=sys.stderr)
+    cleanup_processes()
+    sys.exit(0)
+
+def func(line_a_path, line_b_path, root=None, **kwargs):
+    """
+    모델 학습 + 검증 후 점수를 구하는 예시 함수
+    실제로는 이 부분에 모델 학습 및 평가 코드가 들어갈 것
+    """
+    brightness = kwargs.get('brightness', 0)
+    contrast = kwargs.get('contrast', 0)
+    saturation = kwargs.get('saturation', 0)
+    hue = kwargs.get('hue', 0)
+
+    # A 클래스 인스턴스 생성 시 경로 매개변수 전달
+    class_a = A(root=root, line_a_path=line_a_path, line_b_path=line_b_path)
+    
+    # func 메서드에는 색상 조정 매개변수만 전달
+    score = class_a.func(brightness=brightness, contrast=contrast, saturation=saturation, hue=hue)
+
+    return score
+
+
+def get_trial_params(server_url, study_id=None, max_retries=3):
+    """
+    서버에서 새 trial 파라미터를 요청
+    study_id가 None이면 서버가 새 study_id를 생성해서 반환
+    """
+
+    endpoint = f"{server_url}/trial"
+    if study_id:
+        endpoint += f"?study_id={study_id}"
+
+    for retry in range(max_retries):
+        try:
+            print(
+                f"[Client] 새 trial 파라미터 요청 중... (시도 {retry+1}/{max_retries})", file=sys.stderr)
+
+            # 요청 전송
+            response = requests.get(endpoint, timeout=10)
+
+            if response.status_code == 200:
+                data = response.json()
+                study_id = data["study_id"]
+                params = data["params"]
+                print(
+                    f"[Client] 새 trial 파라미터 수신 성공: study_id={study_id}, params={params}", file=sys.stderr)
+                return study_id, params
+            else:
+                print(
+                    f"[Client] 파라미터 요청 실패: HTTP {response.status_code} - {response.text}", file=sys.stderr)
+                study_id = study_id + f"_{retry}"
+
+        except requests.RequestException as e:
+            print(f"[Client] 요청 중 오류 발생: {e}", file=sys.stderr)
+
+        # 마지막 시도가 아니면 재시도
+        if retry < max_retries - 1:
+            wait_time = (2 ** retry) * (0.5 + 0.5 * random.random())
+            print(f"[Client] {wait_time:.1f}초 후 재시도...", file=sys.stderr)
+            time.sleep(wait_time)
+
+    print("[Client] 최대 재시도 횟수 초과, 파라미터 요청 실패", file=sys.stderr)
+    return None, None
+
+
+def submit_score(server_url, study_id, score, max_retries=3):
+    """
+    trial 결과 점수를 서버에 제출
+    """
+    endpoint = f"{server_url}/score?study_id={study_id}"
+    
+    # numpy.float32를 Python float으로 변환하여 JSON 직렬화 가능하게 함
+    if hasattr(score, 'item'):  # numpy.float32 또는 torch.Tensor인 경우
+        score = float(score.item())
+    else:
+        score = float(score)  # 다른 타입도 float으로 변환
+        
+    payload = {"score": score}
+
+    for retry in range(max_retries):
+        try:
+            print(
+                f"[Client] 점수 제출 중: score={score}, study_id={study_id} (시도 {retry+1}/{max_retries})", file=sys.stderr)
+
+            # 요청 전송
+            response = requests.post(endpoint, json=payload, timeout=10)
+
+            if response.status_code == 200:
+                print(f"[Client] 점수 제출 성공!", file=sys.stderr)
+                return True
+            else:
+                print(
+                    f"[Client] 점수 제출 실패: HTTP {response.status_code} - {response.text}", file=sys.stderr)
+
+        except requests.RequestException as e:
+            print(f"[Client] 요청 중 오류 발생: {e}", file=sys.stderr)
+
+        # 마지막 시도가 아니면 재시도
+        if retry < max_retries - 1:
+            wait_time = (2 ** retry) * (0.5 + 0.5 * random.random())
+            print(f"[Client] {wait_time:.1f}초 후 재시도...", file=sys.stderr)
+            time.sleep(wait_time)
+
+    print("[Client] 최대 재시도 횟수 초과, 점수 제출 실패", file=sys.stderr)
+    return False
+
+
+def get_best_params(server_url, study_id, max_retries=3):
+    """
+    최고의 파라미터를 서버에 요청
+    """
+    endpoint = f"{server_url}/best?study_id={study_id}"
+
+    for retry in range(max_retries):
+        try:
+            print(f"[Client] 최고 파라미터 요청 중... (시도 {retry+1}/{max_retries})", file=sys.stderr)
+
+            # 요청 전송
+            response = requests.get(endpoint, timeout=10)
+
+            if response.status_code == 200:
+                data = response.json()
+                best_params = data["params"]
+                print(f"[Client] 최고 파라미터 수신 성공: {best_params}", file=sys.stderr)
+                return best_params
+            else:
+                print(
+                    f"[Client] 최고 파라미터 요청 실패: HTTP {response.status_code} - {response.text}", file=sys.stderr)
+
+        except requests.RequestException as e:
+            print(f"[Client] 요청 중 오류 발생: {e}", file=sys.stderr)
+
+        # 마지막 시도가 아니면 재시도
+        if retry < max_retries - 1:
+            wait_time = (2 ** retry) * (0.5 + 0.5 * random.random())
+            print(f"[Client] {wait_time:.1f}초 후 재시도...", file=sys.stderr)
+            time.sleep(wait_time)
+
+    print("[Client] 최대 재시도 횟수 초과, 최고 파라미터 요청 실패", file=sys.stderr)
+    return None
+
+
+def report_progress(progress, study_id=None, current_trial=None, total_trials=None, best_value=None, best_params=None):
+    """
+    진행 상황과 study_id를 Electron에 보고하는 함수
+    
+    매개변수:
+        progress: 0에서 100 사이의 진행률
+        study_id: Study ID (선택적)
+        current_trial: 현재 trial 번호
+        total_trials: 총 trial 수
+        best_value: 현재까지의 최고 점수
+        best_params: 현재까지의 최고 파라미터
+    """
+    # JSON 형식으로 진행 상황 보고
+    progress_data = {
+        "progress": round(progress, 2),
+        "status": "running"
+    }
+    
+    # 추가 정보가 있으면 포함
+    if study_id:
+        progress_data["study_id"] = study_id
+    if current_trial is not None and total_trials is not None:
+        progress_data["current_trial"] = current_trial
+        progress_data["total_trials"] = total_trials
+    if best_value is not None:
+        progress_data["best_value"] = round(float(best_value), 4)
+    if best_params is not None:
+        progress_data["best_params"] = best_params
+        
+    # stdout으로 JSON 출력 (Electron과의 통신용)
+    print(json.dumps(progress_data))
+    sys.stdout.flush()
+
+def worker_process(process_id, line_a_path, line_b_path, root, get_params_queue, params_result_queue, 
+                  submit_score_queue, submission_result_queue, max_trials_per_worker):
+    """
+    자식 프로세스에서 실행되는 워커 함수
+    """
+    print(f"[Worker-{process_id}] 워커 프로세스 시작", file=sys.stderr)
+    trials_completed = 0
+    
+    try:
+        while trials_completed < max_trials_per_worker:
+            # 파라미터 요청을 큐에 추가
+            get_params_queue.put(process_id)
+            print(f"[Worker-{process_id}] 파라미터 요청 큐에 추가", file=sys.stderr)
+            
+            # 결과 대기
+            result = params_result_queue.get()
+            if result.get('process_id') != process_id:
+                # 다른 프로세스의 결과면 다시 큐에 넣고 재시도
+                params_result_queue.put(result)
+                time.sleep(0.1)
+                continue
+                
+            if not result.get('success'):
+                print(f"[Worker-{process_id}] 파라미터 요청 실패, 종료합니다", file=sys.stderr)
+                break
+                
+            study_id = result.get('study_id')
+            params = result.get('params')
+            
+            # 파라미터로 모델 학습 및 평가
+            print(f"[Worker-{process_id}] 받은 파라미터로 모델 학습 중: {params}", file=sys.stderr)
+            score = func(line_a_path, line_b_path, root, **params)
+            print(f"[Worker-{process_id}] 모델 평가 완료: 점수 = {score:.6f}", file=sys.stderr)
+            
+            # 점수 제출 요청을 큐에 추가
+            submit_score_queue.put({
+                'process_id': process_id,
+                'study_id': study_id,
+                'score': score
+            })
+            print(f"[Worker-{process_id}] 점수 제출 큐에 추가", file=sys.stderr)
+            
+            # 제출 결과 대기
+            submission_result = submission_result_queue.get()
+            if submission_result.get('process_id') != process_id:
+                # 다른 프로세스의 결과면 다시 큐에 넣고 재시도
+                submission_result_queue.put(submission_result)
+                time.sleep(0.1)
+                continue
+                
+            if not submission_result.get('success'):
+                print(f"[Worker-{process_id}] 점수 제출 실패, 종료합니다", file=sys.stderr)
+                break
+                
+            trials_completed += 1
+            print(f"[Worker-{process_id}] Trial {trials_completed}/{max_trials_per_worker} 완료", file=sys.stderr)
+            
+    except Exception as e:
+        print(f"[Worker-{process_id}] 오류 발생: {e}", file=sys.stderr)
+        traceback.print_exc(file=sys.stderr)
+    
+    print(f"[Worker-{process_id}] 워커 프로세스 종료 (총 {trials_completed} trials 완료)", file=sys.stderr)
+
+def main():
+    # 시그널 핸들러 등록
+    signal.signal(signal.SIGINT, signal_handler)
+    signal.signal(signal.SIGTERM, signal_handler)
+    
+    # 프로그램 종료 시 cleanup 함수 등록
+    atexit.register(cleanup_processes)
+    
+    parser = argparse.ArgumentParser(description="하이퍼파라미터 최적화 클라이언트")
+    # xfeat_aligner.py와 같은 필수 위치 인수 추가
+    parser.add_argument('line_a_path', help='첫 번째 이미지 라인 폴더 경로')
+    parser.add_argument('line_b_path', help='두 번째 이미지 라인 폴더 경로')
+    parser.add_argument('--root', help='root 폴더')
+    
+    # 기존 매개변수 유지
+    parser.add_argument("--server_url", type=str,
+                        default="http://10.164.4.103:8005", help="서버 URL")
+    parser.add_argument("--study_id", type=str, default=None,
+                        help="Study ID (없으면 자동 생성)")
+    parser.add_argument("--max_trials", type=int,
+                        default=30000, help="수행할 최대 trial 수")
+    # 멀티프로세싱 관련 매개변수 추가
+    parser.add_argument("--num_processes", type=int,
+                        default=1, help="사용할 프로세스 수") # /home/hee/electron_project/project/python_scripts/memory/nnscorer_search_index.faiss 를 모두 공유하기 때문에 지금은 1개만 사용해야 함
+    args = parser.parse_args()
+
+
+    print(f"[Client] 하이퍼파라미터 최적화 시작", file=sys.stderr)
+    print(f"[Client] - 첫 번째 이미지 라인: {args.line_a_path}", file=sys.stderr)
+    print(f"[Client] - 두 번째 이미지 라인: {args.line_b_path}", file=sys.stderr)
+    print(f"[Client] - Root 폴더: {args.root}", file=sys.stderr)
+    print(f"[Client] - 서버 URL: {args.server_url}", file=sys.stderr)
+    print(f"[Client] - Study ID: {args.study_id if args.study_id else '자동 생성'}", file=sys.stderr)
+    print(f"[Client] - 최대 Trial 수: {args.max_trials}", file=sys.stderr)
+    print(f"[Client] - 프로세스 수: {args.num_processes}", file=sys.stderr)
+
+    
+    study_id = args.study_id
+    # 현재 날짜시간 정보를 study_id 뒤에 붙이기
+    if study_id:
+        current_time = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
+        study_id = f"{study_id}_{current_time}"
+    
+    max_trials = args.max_trials
+    best_score = None
+    best_params = None
+    trial_count = 0
+
+
+    # 큐 생성
+    get_params_queue = Queue()       # 파라미터 요청 큐
+    params_result_queue = Queue()    # 파라미터 결과 큐
+    submit_score_queue = Queue()     # 점수 제출 큐
+    submission_result_queue = Queue() # 제출 결과 큐
+    
+    # 각 워커 프로세스가 처리할 trial 수 계산
+    max_trials_per_worker = max_trials // args.num_processes
+    if max_trials % args.num_processes > 0:
+        max_trials_per_worker += 1
+
+    report_progress(0, study_id=study_id, current_trial=0, total_trials=max_trials, best_value=None)
+
+    # 워커 프로세스 시작
+    global child_processes
+    processes = []
+    for i in range(args.num_processes):
+        p = Process(target=worker_process, args=(
+            i, args.line_a_path, args.line_b_path, args.root, 
+            get_params_queue, params_result_queue, submit_score_queue, 
+            submission_result_queue, max_trials_per_worker
+        ))
+        # 데몬 프로세스로 설정하여 메인 프로세스가 종료되면 함께 종료되도록 함
+        p.daemon = True
+        p.start()
+        processes.append(p)
+    
+    # 전역 변수에 프로세스 리스트 저장
+    child_processes = processes
+    
+    try:
+        # 큐 모니터링 메인 루프
+        active_processes = len(processes)
+        while active_processes > 0 and trial_count < max_trials:
+            # 살아있는 프로세스 수 확인
+            active_processes = sum(p.is_alive() for p in processes)
+            
+            # 파라미터 요청 큐 처리
+            if not get_params_queue.empty():
+                process_id = get_params_queue.get()
+                print(f"[Main] 프로세스 {process_id}의 파라미터 요청 처리 중", file=sys.stderr)
+                
+                # 서버에서 파라미터 요청
+                new_study_id, params = get_trial_params(args.server_url, study_id)
+                
+                if new_study_id and params:
+                    # 성공 시 study_id 업데이트 (첫 번째 요청인 경우)
+                    if not study_id:
+                        study_id = new_study_id
+                    
+                    # 결과를 파라미터 결과 큐에 추가
+                    params_result_queue.put({
+                        'process_id': process_id,
+                        'success': True,
+                        'study_id': new_study_id,
+                        'params': params
+                    })
+                else:
+                    # 실패 시 오류 결과 전달
+                    params_result_queue.put({
+                        'process_id': process_id,
+                        'success': False
+                    })
+            
+            # 점수 제출 큐 처리
+            if not submit_score_queue.empty():
+                data = submit_score_queue.get()
+                process_id = data['process_id']
+                score_study_id = data['study_id']
+                score = data['score']
+                
+                print(f"[Main] 프로세스 {process_id}의 점수 제출 처리 중", file=sys.stderr)
+                
+                # 서버에 점수 제출
+                success = submit_score(args.server_url, score_study_id, score)
+                
+                # 최고 점수 업데이트
+                if success and (best_score is None or score > best_score):
+                    best_score = score
+                    # 최고 파라미터 요청
+                    current_best_params = get_best_params(args.server_url, score_study_id)
+                    if current_best_params:
+                        best_params = current_best_params
+                        print(f"[Main] 현재까지 최고 파라미터: {best_params}", file=sys.stderr)
+                
+                # 결과를 제출 결과 큐에 추가
+                submission_result_queue.put({
+                    'process_id': process_id,
+                    'success': success
+                })
+                
+                # Trial 카운트 증가 및 진행 상황 보고
+                trial_count += 1
+                progress = (trial_count / max_trials) * 100
+                report_progress(progress, study_id=study_id, current_trial=trial_count, 
+                               total_trials=max_trials, best_value=best_score, best_params=best_params)
+                
+                print(f"[Main] Trial {trial_count}/{max_trials} 완료 (진행률: {progress:.2f}%)", file=sys.stderr)
+            
+            # 1초마다 큐 확인
+            time.sleep(1)
+        
+        # 모든 프로세스가 종료되었거나 최대 trial 수에 도달
+        print(f"[Main] 모든 워커 프로세스 종료 대기 중...", file=sys.stderr)
+        cleanup_processes()
+        
+        # 모든 trial 완료 후 최종 확인
+        if trial_count > 0:
+            print("\n[Client] === 최고 파라미터 최종 확인 ===", file=sys.stderr)
+            final_best_params = get_best_params(args.server_url, study_id)
+
+            if final_best_params:
+                # 최고 파라미터로 최종 평가 - 명령줄 인수도 함께 전달
+                final_score = func(args.line_a_path, args.line_b_path, args.root, **final_best_params)
+                print(f"\n[Client] === 최고 파라미터 최종 평가 ===", file=sys.stderr)
+                print(f"[Client] - 파라미터: {final_best_params}", file=sys.stderr)
+                print(f"[Client] - 최종 점수: {final_score:.6f}", file=sys.stderr)
+                best_score = final_score
+                best_params = final_best_params
+            else:
+                print("[Client] 최고 파라미터를 받을 수 없습니다.", file=sys.stderr)
+
+    except KeyboardInterrupt:
+        print("\n[Client] 사용자에 의해 중단되었습니다.", file=sys.stderr)
+        cleanup_processes()
+    except Exception as e:
+        print(f"[Client] 오류 발생: {e}", file=sys.stderr)
+        traceback.print_exc(file=sys.stderr)
+        cleanup_processes()
+
+    print(f"\n[Client] 총 {trial_count}/{max_trials} trial 완료", file=sys.stderr)
+    
+    # 완료 메시지 전송
+    completion_data = {
+        "progress": 100,
+        "status": "complete",
+        "study_id": study_id,
+        "success": True,
+        "best_value": round(float(best_score), 4) if best_score is not None else None,
+        "best_params": best_params
+    }
+    
+    print(json.dumps(completion_data))
+    sys.stdout.flush()
+    
+    print("[Client] 클라이언트 종료", file=sys.stderr)
+
+
+if __name__ == "__main__":
+    main()
diff --git a/project/python_scripts/hpo_onnx.py b/project/python_scripts/hpo_onnx.py
new file mode 100644
index 0000000..9855cc4
--- /dev/null
+++ b/project/python_scripts/hpo_onnx.py
@@ -0,0 +1,167 @@
+import torch
+import torchvision.transforms as T
+from torch.utils.data import DataLoader
+import numpy as np
+import os
+import argparse
+
+# Import classes, constants and functions from dist_onnx
+from dist_onnx import (
+    RESIZE_SIZE, ANOMALY_MAP_FOLDER, MEMORY_BANK_FOLDER, MODEL_PATH, NUM_WORKERS,
+    IMAGENET_MEAN, IMAGENET_STD, USE_IMAGENET_NORM, CENTER_CROP_RATE,
+    init_directories, get_image_paths, calculate_image_statistics,
+    TransformedDataset, load_onnx_model, get_patch_features,
+    create_memory_bank, compute_top_anomaly_scores, compute_anomaly_map,
+    A as BaseA  # Import A class from dist_onnx as BaseA
+)
+
+# ------------------------------- Class A ----------------------------- #
+
+class A(BaseA):
+    def __init__(self, root="", line_a_path="", line_b_path=""):
+        # 경로 설정
+        self.root = root
+        self.line_a_path = line_a_path
+        self.line_b_path = line_b_path
+
+        # 폴더 및 모델 경로 설정
+        self.anomaly_map_folder = os.path.join(root, ANOMALY_MAP_FOLDER)
+        self.memory_bank_folder = os.path.join(root, MEMORY_BANK_FOLDER)
+        self.model_path = os.path.join(root, MODEL_PATH)
+        
+        # 디렉토리 초기화
+        init_directories(self.anomaly_map_folder, self.memory_bank_folder)
+
+        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
+        self.model = load_onnx_model(self.model_path)
+
+        # ONNX 모델은 이미 정규화가 포함되어 있으므로 0-1 범위로만 변환 (정규화 생략)
+        print("ONNX 모델은 이미 ImageNet 정규화가 포함되어 있어 추가 정규화를 생략합니다.")
+        self.folder_a_mean = None
+        self.folder_a_std = None
+        self.folder_b_mean = None
+        self.folder_b_std = None
+        
+        print(f"CENTER_CROP_RATE: {CENTER_CROP_RATE}")
+        print(f"LOCAL_FOLDER_A: {line_a_path}")
+        print(f"LOCAL_FOLDER_B: {line_b_path}")
+        
+        # 데이터셋 초기화 - 8:2 비율로 train/test 분할
+        self.train_ratio = 0.8
+        
+        # A 라인 데이터셋 (train/test)
+        self.ds_a_training = TransformedDataset(
+            line_a_path,
+            transform=None,
+            resize=True,
+            mean=self.folder_a_mean,
+            std=self.folder_a_std,
+            limit=50,
+            train_split=self.train_ratio
+        )
+        
+        self.ds_a_test = TransformedDataset(
+            line_a_path,
+            transform=None,
+            resize=True,
+            mean=self.folder_a_mean,
+            std=self.folder_a_std,
+            limit=30,
+            train_split=-self.train_ratio  # 음수 값은 test set을 의미
+        )
+        
+        # B 라인 데이터셋 (train/test)
+        self.ds_b_training = TransformedDataset(
+            line_b_path,
+            transform=None,
+            resize=True,
+            mean=self.folder_b_mean,
+            std=self.folder_b_std,
+            limit=50,
+            train_split=self.train_ratio
+        )
+        
+        self.ds_b_test = TransformedDataset(
+            line_b_path,
+            transform=None,
+            resize=True,
+            mean=self.folder_b_mean,
+            std=self.folder_b_std,
+            limit=30,
+            train_split=-self.train_ratio  # 음수 값은 test set을 의미
+        )
+        
+        # 컬러 변환된 데이터셋 (초기 transform은 None으로 설정)
+        self.ds_a_color = TransformedDataset(
+            line_a_path,
+            transform=None,
+            resize=True,
+            mean=None,
+            std=None,
+            selected_paths=self.ds_a_training.image_paths.copy()  # 동일한 이미지 사용
+        )
+
+    # hpo_onnx.py 전용 함수 구현
+    def func(self, brightness: float = 0.0, contrast: float = 0.0, saturation: float = 0.0, hue: float = 0.0) -> float:
+        """
+        1) A_TRAIN_COLOR 생성: A_TRAIN 각 이미지에 ColorJitter 파라미터 내에서 랜덤한 색상 변환 적용
+        2) A_TRAIN + A_TRAIN_COLOR 로 메모리 뱅크 생성
+        3) 차이 점수 계산: B_TEST와 A_TEST 간의 anomaly score 차이 계산 후 반환
+        
+        Args:
+            brightness: 밝기 변화 최대 강도 (0: 변화 없음, 값이 클수록 더 큰 변화 가능성)
+            contrast: 대비 변화 최대 강도 (0: 변화 없음, 값이 클수록 더 큰 변화 가능성)
+            saturation: 채도 변화 최대 강도 (0: 변화 없음, 값이 클수록 더 큰 변화 가능성)
+            hue: 색조 변화 최대 강도 (0: 변화 없음, 값이 클수록 더 큰 변화 가능성)
+
+        HPO 파라미터 범위 추천:
+        - brightness: 0.0 ~ 0.5
+        - contrast: 0.0 ~ 0.5
+        - saturation: 0.0 ~ 0.5
+        - hue: 0.0 ~ 0.2
+        
+        Returns:
+            float: B_TEST와 A_TEST 간의 anomaly score 차이
+
+        """
+        print(f"ColorJitter 파라미터: brightness={brightness}, contrast={contrast}, saturation={saturation}, hue={hue}")
+        
+        # 결과 저장용 디렉토리 생성
+        os.makedirs(self.memory_bank_folder, exist_ok=True)
+        os.makedirs(self.anomaly_map_folder, exist_ok=True)
+
+        # A_TRAIN 및 A_TEST 데이터로더 생성
+        dl_a_training = DataLoader(self.ds_a_training, batch_size=1, shuffle=False, num_workers=NUM_WORKERS)
+        dl_a_test = DataLoader(self.ds_a_test, batch_size=1, shuffle=False, num_workers=NUM_WORKERS)
+
+        # A_COLOR transform 업데이트 (init에서 생성된 데이터셋 재사용)
+        color_tf = T.ColorJitter(brightness=brightness, contrast=contrast, saturation=saturation, hue=hue)
+        self.ds_a_color.update_transform(color_tf)
+        dl_a_color = DataLoader(self.ds_a_color, batch_size=1, shuffle=False, num_workers=NUM_WORKERS)
+        
+        # B_TEST 데이터로더 생성
+        dl_b_test = DataLoader(self.ds_b_test, batch_size=1, shuffle=False, num_workers=NUM_WORKERS)
+        
+        # --- 메모리 뱅크 (A_TRAINING + A_COLOR) --- #
+        mb_mgr = create_memory_bank(
+            [self.line_a_path, f"{self.line_a_path}_COLOR1", f"{self.line_a_path}_COLOR2", f"{self.line_a_path}_COLOR3"],
+            self.model,
+            [dl_a_training, dl_a_color, dl_a_color, dl_a_color],
+            memory_bank_folder=self.memory_bank_folder,
+        )
+
+        # --- A_TEST에 대한 anomaly score 계산 --- #
+        results_a_test = compute_top_anomaly_scores(dl_a_test, mb_mgr, self.model, top_percent=0.1)
+        mean_score_a = float(np.mean([r["top_mean_score"] for r in results_a_test])) if results_a_test else 0.0
+        
+        # --- B_TEST에 대한 anomaly score 계산 --- #
+        results_b_test = compute_top_anomaly_scores(dl_b_test, mb_mgr, self.model, top_percent=0.1)
+        mean_score_b = float(np.mean([r["top_mean_score"] for r in results_b_test])) if results_b_test else 0.0
+
+        # B_TEST와 A_TEST 간의 차이 반환
+        score_diff = mean_score_b - mean_score_a
+        print(f"A_TEST 평균 점수: {mean_score_a}")
+        print(f"B_TEST 평균 점수: {mean_score_b}")
+        print(f"차이 점수: {score_diff}")
+        
+        return -score_diff # 최소화 문제로 변환
\ No newline at end of file
diff --git a/project/python_scripts/xfeat_aligner.py b/project/python_scripts/xfeat_aligner.py
new file mode 100644
index 0000000..a0b02e1
--- /dev/null
+++ b/project/python_scripts/xfeat_aligner.py
@@ -0,0 +1,363 @@
+import os
+import time
+import numpy as np
+import cv2
+import onnxruntime as ort
+from tqdm import tqdm
+import argparse
+import json
+import sys
+
+class XFeatAligner:
+    def __init__(self, model_path, input_size=512):
+        """
+        XFeat 기반 이미지 정렬 클래스 초기화
+        
+        매개변수:
+            model_path: ONNX 모델 파일 경로
+            input_size: 입력 이미지 크기
+        """
+        self.input_size = input_size
+        self.model_path = model_path
+        self.session = ort.InferenceSession(model_path, providers=["CUDAExecutionProvider"])
+    
+    def _load_model(self, provider="CPUExecutionProvider"):
+        """
+        지정된 공급자로 ONNX 모델 로드
+        
+        매개변수:
+            provider: ONNX 실행 공급자 ("CPUExecutionProvider" 또는 "CUDAExecutionProvider")
+        """
+        session = ort.InferenceSession(self.model_path, providers=[provider])
+        print(session.get_providers())
+        return session
+    
+    def warp_corners_and_draw_matches(self, ref_points, dst_points, img1, img2):
+        """
+        두 이미지 간의 매칭점을 시각화하고 첫 번째 이미지의 경계를 두 번째 이미지에 투영합니다.
+        
+        매개변수:
+            ref_points: 참조 이미지의 특징점 좌표
+            dst_points: 대상 이미지의 특징점 좌표
+            img1: 참조 이미지
+            img2: 대상 이미지
+            
+        반환값:
+            두 이미지의 매칭점과 투영된 경계가 표시된 결합 이미지
+        """
+        # Homography 행렬 계산 (USAC_MAGSAC 알고리즘 사용)
+        H, mask = cv2.findHomography(ref_points, dst_points, cv2.USAC_MAGSAC, 3.5, maxIters=1_000, confidence=0.999)
+        mask = mask.flatten()
+
+        # 첫 번째 이미지(img1)의 모서리 좌표 가져오기
+        h, w = img1.shape[:2]
+        corners_img1 = np.array([[0, 0], [w-1, 0], [w-1, h-1], [0, h-1]], dtype=np.float32).reshape(-1, 1, 2)
+
+        # Homography를 사용하여 모서리 좌표를 두 번째 이미지(img2) 공간으로 변환
+        warped_corners = cv2.perspectiveTransform(corners_img1, H)
+
+        # 두 번째 이미지에 변환된 모서리 그리기
+        img2_with_corners = img2.copy()
+        for i in range(len(warped_corners)):
+            start_point = tuple(warped_corners[i-1][0].astype(int))
+            end_point = tuple(warped_corners[i][0].astype(int))
+            cv2.line(img2_with_corners, start_point, end_point, (0, 255, 0), 4)  # 모서리를 녹색 실선으로 표시
+
+        # cv2.drawMatches 함수를 위한 키포인트 및 매치 준비
+        keypoints1 = [cv2.KeyPoint(p[0], p[1], 5) for p in ref_points]
+        keypoints2 = [cv2.KeyPoint(p[0], p[1], 5) for p in dst_points]
+        matches = [cv2.DMatch(i,i,0) for i in range(len(mask)) if mask[i]]
+
+        # 인라이어 매치 그리기
+        img_matches = cv2.drawMatches(img1, keypoints1, img2_with_corners, keypoints2, matches, None,
+                                    matchColor=(0, 255, 0), flags=2)
+
+        return img_matches
+    
+    def align(self, ref_img_path, src_folder_path, save_visualizations=False, callback=None):
+        """
+        참조 이미지에 맞춰 대상 폴더의 모든 이미지를 정렬
+        
+        매개변수:
+            ref_img_path: 참조 이미지 파일 경로
+            src_folder_path: 정렬할 이미지가 있는 소스 폴더 경로
+            save_visualizations: 시각화 결과를 저장할지 여부
+            callback: 진행 상황을 보고하기 위한 콜백 함수
+            
+        반환값:
+            정렬된 이미지가 저장된 폴더 경로
+        """
+
+        # 참조 이미지 로드
+        ref_img = cv2.imread(ref_img_path)
+        if ref_img is None:
+            raise ValueError(f"참조 이미지를 로드할 수 없습니다: {ref_img_path}")
+        
+        # 정렬된 이미지를 저장할 출력 디렉토리 생성
+        if src_folder_path.endswith('/') or src_folder_path.endswith('\\'):
+            src_folder_path = src_folder_path[:-1]
+
+        dst_folder_path = src_folder_path + '_aligned'
+
+        # 출력 디렉토리가 없으면 생성
+        os.makedirs(dst_folder_path, exist_ok=True)
+            
+        # 시각화 결과를 저장할 폴더 (옵션)
+        if save_visualizations:
+            vis_folder_path = src_folder_path + '_visualization'
+            os.makedirs(vis_folder_path, exist_ok=True)
+                
+        # 참조 이미지 크기 조정
+        resized_ref_img = cv2.resize(ref_img, (self.input_size, self.input_size))
+        
+        # 입력 디렉토리의 이미지 목록 가져오기
+        img_list = [f for f in os.listdir(src_folder_path) if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
+        total_images = len(img_list)
+        
+        # 각 테스트 이미지에 대해 정렬 수행
+        for idx, img_name in enumerate(tqdm(img_list, desc=f"정렬 중 {os.path.basename(src_folder_path)}")):
+            # 진행 상황 계산 및 보고
+            progress = (idx / total_images) * 100
+            if callback:
+                callback(progress)
+            
+            # 출력 파일 경로 확인
+            output_path = os.path.join(dst_folder_path, img_name)
+            
+            # 이미 출력 파일이 존재하면 건너뛰기
+            if os.path.exists(output_path):
+                print(f"파일이 이미 존재합니다, 건너뜁니다: {output_path}")
+                continue
+                
+            # 테스트 이미지 로드 및 크기 조정
+            test_img_path = os.path.join(src_folder_path, img_name)
+            test_img = cv2.imread(test_img_path)
+            if test_img is None:
+                print(f"경고: 이미지를 로드할 수 없습니다: {test_img_path}")
+                continue
+                
+            resized_test_img = cv2.resize(test_img, (self.input_size, self.input_size))
+            
+            # XFeat 모델 입력 준비
+            ort_input = {
+                'image1': np.array([resized_ref_img], dtype=np.float32),  # 참조 이미지      
+                'image2': np.array([resized_test_img], dtype=np.float32),  # 테스트 이미지                    
+            }
+            
+            # XFeat 모델 실행하여 매칭 키포인트 획득
+            out = self.session.run(None, ort_input)  
+            mkpts_0 = out[0]  # 참조 이미지의 매칭 키포인트
+            mkpts_1 = out[1]  # 테스트 이미지의 매칭 키포인트
+            
+            if len(mkpts_0) < 4:
+                print(f"경고: {img_name}에 대한 매칭점이 충분하지 않습니다 ({len(mkpts_0)} 발견). 정렬을 건너뜁니다.")
+                continue
+                
+            # 시각화 저장 (옵션)
+            if save_visualizations:
+                vis_path = os.path.join(vis_folder_path, f"vis_{img_name}")
+                # 시각화 파일이 이미 존재하면 건너뛰기
+                if not os.path.exists(vis_path):
+                    canvas = self.warp_corners_and_draw_matches(mkpts_0, mkpts_1, resized_ref_img, resized_test_img)
+                    cv2.imwrite(vis_path, canvas)
+            
+            # 테스트 이미지에서 참조 이미지로 Homography 계산
+            homography, mask = cv2.findHomography(mkpts_1, mkpts_0, cv2.USAC_MAGSAC, 3.5, maxIters=1_000, confidence=0.999)
+            
+            # Homography를 사용하여 테스트 이미지 정렬
+            aligned_img = cv2.warpPerspective(resized_test_img, homography, (resized_test_img.shape[1], resized_test_img.shape[0])) 
+            
+            # 정렬된 이미지 저장
+            cv2.imwrite(output_path, aligned_img)
+        
+        # 완료 후 최종 진행 상황 보고
+        if callback:
+            callback(100)
+            
+        return dst_folder_path
+    
+    def test_time(self, ref_img_path, src_folder_path, num_runs=1):
+        """
+        CPU와 GPU 모드에서의 처리 시간을 비교
+        
+        매개변수:
+            ref_img_path: 참조 이미지 파일 경로
+            src_folder_path: 정렬할 이미지가 있는 소스 폴더 경로
+            num_runs: 신뢰성을 위한 실행 횟수
+            
+        반환값:
+            CPU 및 GPU 평균 처리 시간이 포함된 사전
+        """
+        providers = ["CUDAExecutionProvider", "CPUExecutionProvider"]
+        results = {}
+        
+        for provider in providers:
+            try:
+                # 지정된 공급자로 모델 로드 시도
+                session = self._load_model(provider)
+                
+                # 원래 세션 백업
+                original_session = self.session
+                self.session = session
+                
+                times = []
+                for i in tqdm(range(num_runs), desc=f"실행 중 ({provider})"):
+                    start_time = time.time()
+                    
+                    # 참조 이미지 로드
+                    ref_img = cv2.imread(ref_img_path)
+                    if ref_img is None:
+                        raise ValueError(f"참조 이미지를 로드할 수 없습니다: {ref_img_path}")
+                    
+                    # 참조 이미지 크기 조정
+                    resized_ref_img = cv2.resize(ref_img, (self.input_size, self.input_size))
+                    
+                    # 입력 디렉토리의 이미지 목록 가져오기
+                    img_list = [f for f in os.listdir(src_folder_path) if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
+                    
+                    # 각 테스트 이미지에 대해 정렬 수행
+                    for img_name in tqdm(img_list, desc=f"처리 중 ({provider})", leave=False):
+                        # 테스트 이미지 로드 및 크기 조정
+                        test_img_path = os.path.join(src_folder_path, img_name)
+                        test_img = cv2.imread(test_img_path)
+                        if test_img is None:
+                            continue
+                            
+                        resized_test_img = cv2.resize(test_img, (self.input_size, self.input_size))
+                        
+                        # XFeat 모델 입력 준비
+                        ort_input = {
+                            'image1': np.array([resized_ref_img], dtype=np.float32),  
+                            'image2': np.array([resized_test_img], dtype=np.float32),                   
+                        }
+                        
+                        # XFeat 모델 실행하여 매칭 키포인트 획득
+                        out = self.session.run(None, ort_input)  
+                        mkpts_0 = out[0]  # 참조 이미지의 매칭 키포인트
+                        mkpts_1 = out[1]  # 테스트 이미지의 매칭 키포인트
+                        
+                        if len(mkpts_0) < 4:
+                            continue
+                            
+                        # 테스트 이미지에서 참조 이미지로 Homography 계산
+                        homography, mask = cv2.findHomography(mkpts_1, mkpts_0, cv2.USAC_MAGSAC, 3.5, maxIters=1_000, confidence=0.999)
+                        
+                        # Homography를 사용하여 테스트 이미지 정렬
+                        aligned_img = cv2.warpPerspective(resized_test_img, homography, (resized_test_img.shape[1], resized_test_img.shape[0]))
+                        
+                    elapsed_time = time.time() - start_time
+                    times.append(elapsed_time)
+                
+                # 원래 세션 복원
+                self.session = original_session
+                
+                # 평균 시간 계산
+                avg_time = sum(times) / len(times)
+                results[provider] = avg_time
+                print(f"{provider} 평균 처리 시간: {avg_time:.4f}초 ({num_runs}회 실행)")
+                
+            except Exception as e:
+                print(f"{provider} 실행 중 오류 발생: {str(e)}")
+                results[provider] = None
+        
+        # CPU와 GPU 속도 차이 계산 (GPU가 사용 가능한 경우)
+        if "CUDAExecutionProvider" in results and results["CUDAExecutionProvider"] is not None and results["CPUExecutionProvider"] is not None:
+            speedup = results["CPUExecutionProvider"] / results["CUDAExecutionProvider"]
+            print(f"GPU 속도 향상: CPU 대비 {speedup:.2f}배 빠름")
+        
+        return results
+
+def find_first_image_in_folder(folder_path):
+    """
+    폴더에서 파일명 순으로 첫 번째 이미지 파일 찾기
+    
+    매개변수:
+        folder_path: 이미지를 검색할 폴더 경로
+        
+    반환값:
+        첫 번째 이미지 파일의 전체 경로
+    """
+    # 이미지 파일 목록 가져오기
+    img_list = [f for f in os.listdir(folder_path) if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
+    
+    if not img_list:
+        raise ValueError(f"{folder_path}에서 이미지 파일을 찾을 수 없습니다.")
+    
+    # 파일명 순으로 정렬
+    img_list.sort()
+    
+    # 첫 번째 이미지의 전체 경로 반환
+    return os.path.join(folder_path, img_list[0])
+
+def report_progress(progress):
+    """
+    진행 상황을 Electron에 보고하는 함수
+    
+    매개변수:
+        progress: 0에서 100 사이의 진행률 
+    """
+    # JSON 형식으로 진행 상황 보고
+    progress_data = {
+        "progress": round(progress, 2)
+    }
+    print(json.dumps(progress_data), flush=True)
+
+def main():
+    # 명령줄 인수 파싱
+    parser = argparse.ArgumentParser(description='XFeat 이미지 정렬 도구')
+    parser.add_argument('line_a_path', help='첫 번째 이미지 라인 폴더 경로')
+    parser.add_argument('line_b_path', help='두 번째 이미지 라인 폴더 경로')
+    parser.add_argument('--root', help='root 폴더')
+    parser.add_argument('--model_path', default="models/xfeat_model_512_5000.onnx", help='ONNX 모델 파일 경로')
+    parser.add_argument('--save_vis', action='store_true', help='시각화 결과 저장 여부')
+    
+    args = parser.parse_args()
+    
+    # line_a_path에서 첫 번째 이미지를 참조 이미지로 사용
+    try:
+        ref_img_path = find_first_image_in_folder(args.line_a_path)
+        print(f"참조 이미지로 {ref_img_path}를 사용합니다.")
+    except Exception as e:
+        print(f"오류: {str(e)}")
+        sys.exit(1)
+    
+    # XFeatAligner 인스턴스 생성
+    aligner = XFeatAligner(model_path=args.root + '/' + args.model_path)
+    
+    # 총 이미지 수 계산 (line_a + line_b)
+    line_a_images = [f for f in os.listdir(args.line_a_path) if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
+    line_b_images = [f for f in os.listdir(args.line_b_path) if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
+    total_images = len(line_a_images) + len(line_b_images)
+    
+    # 진행 상황 콜백 함수 - line_a는 전체의 0-50%, line_b는 50-100%
+    def progress_callback_line_a(progress):
+        # line_a의 진행률(0-100%)을 전체 진행률의 0-50%로 변환
+        overall_progress = progress / 2
+        report_progress(overall_progress)
+    
+    def progress_callback_line_b(progress):
+        # line_b의 진행률(0-100%)을 전체 진행률의 50-100%로 변환
+        overall_progress = 50 + (progress / 2)
+        report_progress(overall_progress)
+    
+    # line_a_path 정렬
+    print(f"line_a_path 폴더 {args.line_a_path} 정렬 중...")
+    aligner.align(ref_img_path, args.line_a_path, save_visualizations=args.save_vis, 
+                  callback=progress_callback_line_a)
+    
+    # line_b_path 정렬
+    print(f"line_b_path 폴더 {args.line_b_path} 정렬 중...")
+    aligner.align(ref_img_path, args.line_b_path, save_visualizations=args.save_vis,
+                  callback=progress_callback_line_b)
+    
+    print("모든 폴더 정렬 완료")
+    
+    # 완료 메시지 전송
+    completion_data = {
+        "progress": 100,
+        "status": "complete"
+    }
+    print(json.dumps(completion_data), flush=True)
+
+if __name__ == "__main__":
+    main()
\ No newline at end of file
